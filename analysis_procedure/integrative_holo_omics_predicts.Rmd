---
title: "Integrative holo-omic data analysis predicts interactions across the host-microbiome axis"
subtitle: "3D'omics WP3.2"
author:
  name: "<b>&nbsp;Jenny Merkesvik</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>PhD candidate</i><br><br><i class='glyphicon glyphicon-education'></i><b>&nbsp;&nbsp;Norwegian University of Life Science</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Faculty of Chemistry, Biotechnology,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and Food Science"
date: "&nbsp;Last updated: `r format(Sys.time(), '%d.%m.%y, %R %Z')`"
bibliography: /Users/jennymerkesvik/Documents/Referanser/ref_lib.bib
csl: /Users/jennymerkesvik/Documents/Referanser/vancouver.csl
output:
  rmdformats::robobook:
    css: style.css
    number_sections: true
    scroll_highlight: true
    toc_depth: 6
    anchor_sections: true
    fig_caption: true
    df_print: paged
    code_folding: hide
    code_download: true
    code_copy: true
    code_console: false
    lightbox: true
    gallery: true
    includes:
      in_header: header.html
editor_options: 
  chunk_output_type: inline
---

```{r setup, echo = F}
# --GLOBAL CHUNK OPTIONS--------------------
knitr::opts_chunk$set(message = F,
                      warning = F,
                      fig.align = "center",
                      fig.width = 15)
knitr::opts_knit$set(root.dir = "~/Documents/3D_omics/WP3/integrative_holo_omics_predicts/")
```

```{=html}
<!------------ Add logo right of document title and subtitle ------------>
<style>
div.page-inner h1.title {
   height: 100px;
   background-image: url("figures/3Domics_logo_grant_number.png");
   background-size: 300px;
   background-position: right 0px top;
   background-repeat: no-repeat;
}
</style>

<!------------ Adjust title text wrapping before logo ------------>
<style>
.book .book-body .page-inner section.normal h1.title {
  font-size: 2.5em;
  margin-top: 0px;
  padding-right: 330px;
  padding-bottom: 60px;
  height: calc(120% + 250px);
}
</style>

<!------------ Move subtitle to account for title padding ------------>
<style>
 .book .book-body .page-inner section.normal h1.subtitle {
    margin-top: -60px;
}
 </style>
 
 <!------------ header.html adds 3D'omics favicon to browser tab of report ------------>
```

**Merkesvik J ^a^\*, Langa JE ^bc^, Pietroni C ^c^, Alberdi A ^c^, Poulsen LL ^d^, Bojesen AM ^d^, Meuronen T ^e^, Turunen S ^e^, Kärkkäinen O ^ef^, Westereng B ^a^, Pope PB ^agh^, Hvidsten TR ^a^.**

<font size="2">

^a^ Faculty of Chemistry, Biotechnology, and Food Science; Norwegian University of Life Sciences; Ås, Norway.\
^b^ Faculty of Science and Technology; University of the Basque Country; Leioa, Spain.\
^c^ Centre for Evolutionary Hologenomics; University of Copenhagen; Copenhagen, Denmark.\
^d^ Department of Veterinary and Animal Science, University of Copenhagen; Frederiksberg C, Denmark.\
^e^ Afekta Technologies Ltd; Kuopio, Finland.\
^f^ School of Pharmacy; University of Eastern Finland; Kuopio, Finland.\
^g^ Faculty of Biosciences; Norwegian University of Life Sciences; Ås, Norway.\
^h^ Centre for Microbiome Research; Queensland University of Technology; Woolloongabba, Australia.\
\* Corresponding author, email: [jenny.merkesvik\@nmbu.no](mailto:jenny.merkesvik@nmbu.no){.email}.

</font>

# Abstract {.unnumbered}

This Rmarkdown report outlines the analysis approach for the manuscript "Integrative holo-omic data analysis predicts interactions across the host-microbiome axis". Here, we show that a computational method designed for multi-omic analysis in eukaryotes can be leveraged to integrate and analyse five layers of holo-omic data from porcine hosts and their gut microbiomes. Our data originates from a feeding trial we conducted to investigate the effects of acetylated galactoglucomannan (AcGGM) as a microbiome-directed fibre (MDF) on a porcine holobiont - meaning the pigs themselves and their associated microbiomes seen as one biological entity. The dataset covers five omic layers spanning both sides of the holobiont: metagenomics in the form of 373 metagenome-assembled genomes; gene expression data covering 771,535 microbial and 22,120 host genes; and untargeted metabolomic profiles spanning 6,388 compounds in both digesta and tissue samples. The approach documented herein includes data preprocessing, exploratory data analysis, targeted investigations, the holo-omic integration approach, and visualisations of results. The report is indented as a supplement to the manuscript and as documentation of the programmatic steps of the analysis.

<br>

# Abbreviations {.unnumbered}

```{r abbreviations, echo = F}
# --ABBREVIATIONS--------------------
library(tidyverse)
library(kableExtra)
library(DT)

abbrev <- c("AcGGM" = "acetylated galactoglucomannan",
            "MS/MS" = "tandem mass spectrometry",
            "LFC" = "log2 fold change",
            "FDR" = "false discovery rate",
            "MCFA" = "multiset correlation and factor analysis",
            "MDF" = "microbiota-directed fibre",
            "VST" = "variance-stabilising transformation",
            "MAG" = "metagenome-assembled genome",
            "metaG" = "metagenomics",
            "metaT" = "metatranscriptomics",
            "metaB" = "metabolomics",
            "hostT" = "host transcriptomics",
            "SCFA" = "short-chain fatty acid",
            NULL)

# sorted table
abbrev <- data.frame(Abbreviation = names(abbrev),
                     Description = abbrev,
                     row.names = NULL) %>%
  arrange(tolower(Abbreviation))

# print stylised version of table
# if even number of abbreviations, split into two columns
if (nrow(abbrev)%%2 == 0) {
  data.frame(Abbreviation1 = abbrev[1:round(nrow(abbrev)/2),1],
           Description1 = abbrev[1:round(nrow(abbrev)/2),2],
           space1 = "", space2 = "",
           Abbreviation2 = abbrev[(round(nrow(abbrev)/2)+1):nrow(abbrev),1],
           Description2 = abbrev[(round(nrow(abbrev)/2)+1):nrow(abbrev),2]) %>%
  kable(col.names = NULL,
        toprule = "\\toprule[0pt]", midrule = "\\midrule[0pt]",
        bottomrule = "\\bottomrule[0pt]",
        align = c("r", "l", "c", "c", "r", "l")) %>% 
  kable_styling(bootstrap_options = "striped") %>% 
  column_spec(column = 1:5, extra_css = "vertical-align:middle;")
} else {
  # if odd number of abbreviations, leave empty last entry in second column
    data.frame(Abbreviation1 = abbrev[1:round(nrow(abbrev)/2+1),1],
           Description1 = abbrev[1:round(nrow(abbrev)/2+1),2],
           space1 = "", space2 = "",
           Abbreviation2 = c(abbrev[(round(nrow(abbrev)/2)+1):nrow(abbrev),1], ""),
           Description2 = c(abbrev[(round(nrow(abbrev)/2)+1):nrow(abbrev),2], "")) %>%
    kable(col.names = NULL,
          toprule = "\\toprule[0pt]", midrule = "\\midrule[0pt]",
          bottomrule = "\\bottomrule[0pt]",
          align = c("r", "l", "c", "c", "r", "l")) %>%
  kable_styling(bootstrap_options = "striped") %>% 
  column_spec(column = 1:6, extra_css = "vertical-align:middle;")
}
```

<br>

# Introduction

The samples utilised in the present analysis originate from an *in vivo* feeding trial conducted within the European Union Horizon 2020 project "3D'omics" [[@european_commission_horizon_2020; @3domics-website]]. The trial saw 12 animals - 10 day old male piglets from the same litter - divided into three groups (**Fig. 1A)**. All received the same basal diet (**Suppl. 1**) and started weaning at day 24. Two groups were given AcGGM fibres at 4% inclusion as a dietary supplement. One of these groups was introduced to the fibres post-weaning, while the second received fibres already in their liquid pre-weaning diet. The third group acted as a negative control and did not receive AcGGM fibres at any point (**Fig. 1B**).

After six weeks - following 2 and 4 weeks of AcGGM supplementation for the post- and pre-weaning pig groups, respectively - the animals were euthanised. Up to two types of samples were collected from the caecum of each animal: digesta and tissue from the caecal gut wall (**Fig. 1C**). Each sample was utilised to generate omic data across the pig holobiont: metagenomics (metaG), metatranscriptomics (metaT), untargeted metabolomics (metaB), and host transcriptomics (hostT). With these omic data, we intended to study the impact of AcGGM on the porcine holobiont when introduced at different developmental stages.

However, analyses that use data across the host-microbiota boundary to predict cross-kingdom interactions are complex and differ from non-holo-omic multi-omics, which combine molecular layers from just a single organism. Given the lack of a gold-standard approach for these cross-kingdom analyses, we show herein that a computational method designed for multi-omic analysis in eukaryotes can be leveraged to integrate and analyse these five layers of holo-omic data (**Fig. 1D**).

<br>

```{r design figure, echo = F, out.width = "70%"}
knitr::include_graphics("figures/1_study_concept.png")
```

<font size="2">***Figure 1**. Experimental design, data generation, and holo-omic analysis procedure of the porcine feeding trial with acetylated galactoglucomannan fibres (AcGGM). **A)** Division of 12 piglets into three groups: one control, and two groups introduced to AcGGM at different developmental stages. **B)** Trial timeline reporting milestone events and porcine diets. Solid feed composition is found in Suppl. 1. **C)** Sites for sample collection after 6 weeks – caecal digesta (pink) and gut wall (tan) – and omic data layers generated from these samples. Sampling and data generation steps are described in Suppl. 2. **D)** Proposed two-step methodological framework for predicting host-microbiome interactions. Using multiset correlation and factor analysis (MCFA) [[@brown2023]], observed data (D) are reconstructed as the sum of a shared space (W~S~×F~S~) capturing common data patterns, and private model spaces for each omic layer (W~P~×F~P~) (adapted from [[@kobel2024]]). The fitted weights in the shared space (W~S~) are then used to select features with the most relevance for capturing cross-omic patterns in the dataset. The observed omic data of the reduced feature space (Q) is used to predict direct interactions between host- and microbiota-associated features. Abbreviations: AcGGM: acetylated galactoglucomannan, CAZymes: carbohydrate-active enzymes, CE: carbohydrate esterase, GH: glycoside hydrolase. Figure created in BioRender: Merkesvik J. (2025) [https://biorender.com/e0obj4f](https://biorender.com/e0obj4f){.uri target="_blank"}.*</font>

<br>

This report mirrors the findings described in the manuscript, and shows how the raw omic data files generated by members of the 3D'omics consortium were used to integrate holo-omic data layers and predict cross-kingdom interactions. Specifically, the data tables are processed and standardised, and each omic layer is investigated in light of relevant metadata both independently and through the proposed holo-omic analysis approach. Accompanying the report is a GitHub repository ([jennymerkesvik/3domics_wp3-2](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}) containing all files relevant to the analysis. Within the `data` directory, two versions of each `omic` and `metadata` file exist: `source` data received from project partners; and `processed` files extracting relevant data fields, standardising sample and feature names, and quality filtering of features. Lastly, the `results` directory contains output files from the various analyses described herein.

<br>

# Setup

Loading necessary libraries for data wrangling, analysis tools, and plotting.

```{r packages}
# --INSTALL AND LOAD PACKAGES------------------------
# from github
# devtools::install_github("rstudio/reticulate")

# from CRAN
pacman::p_load( # data wrangling and manipulation
                R.utils,
                tidyverse,
                data.table,
                
                # analysis tools
                DESeq2,
                ape,
                phangorn,
                reticulate,
                
                # tables and figures
                kableExtra,
                DT,
                knitr,
                slickR,
                phytools,
                
                # colours, visuals, and plotting
                ggtree,
                ggtreeExtra,
                ggnewscale,
                ggh4x,
                ggsignif,
                colorspace,
                RColorBrewer
                )
```

Custom functions:

```{r helper functions}
# --CUSTOM FUNCTIONS--------------------------------------------
# convert dataframe outputs to pretty, searchable tables
pretty_table <- function(df, text = "", number = F, name = "latest"){
  # if tab number should be added,
  # will use the latest table number added unless other name specificed
  if(number){
    if(name == "latest") {
    df %>%
      datatable(filter = "top",
                caption = htmltools::tags$caption(htmltools::tags$span(htmltools::tags$span(str_c("Table ", length(tab), ": "), style = "font-weight:bold"),
                                                                       htmltools::tags$span(text, style = ""), style = "color:grey;text-align:center;")),
                options = list(columnDefs = list(list(targets = "_all",
                                                      className = "dt-center",
                                                      render = JS("function(data, type, row, meta) {",
                                                                  "return type === 'display' && data != null && data.length > 30 ?",
                                                                  "'<span title=\"' + data + '\">' + data.substr(0, 30) + '...</span>' : data;", "}")))))
    }
    else {df %>%
        datatable(filter = "top",
                  caption = htmltools::tags$caption(htmltools::tags$span(htmltools::tags$span(str_c("Table ", tab[[name]], ": "), style = "font-weight:bold"),
                                                                         htmltools::tags$span(text, style = ""), style = "color:grey;text-align:center;")),
                  options = list(columnDefs = list(list(targets = "_all",
                                                        className = "dt-center",
                                                        render = JS("function(data, type, row, meta) {",
                                                                    "return type === 'display' && data != null && data.length > 30 ?",
                                                                    "'<span title=\"' + data + '\">' + data.substr(0, 30) + '...</span>' : data;", "}")))))
      
    }
  }
  else {df %>%
      datatable(filter = "top",
                caption = htmltools::tags$caption(htmltools::tags$span(text,
                                                                       style = "color:grey;text-align:center;")),
                options = list(columnDefs = list(list(targets = "_all",
                                                      className = "dt-center",
                                                      render = JS("function(data, type, row, meta) {",
                                                                "return type === 'display' && data != null && data.length > 30 ?",
                                                                "'<span title=\"' + data + '\">' + data.substr(0, 30) + '...</span>' : data;", "}")))))
  }
}

# -----------------------------------------------------------------------------
# random colour palette generator, up to 433 colours
get_colours <- function(n) {
  all <- colours()[grep("gr(a|e)y", colours(), invert = T)]
  if(n %in% 1:length(all)) return(sample(all, n))
  else message(str_c("Enter integer between 1 and ", length(all)))
}
```

<br>

# Input data

## Downloading data

Downloading the necessary data for the analysis. All original files are provided on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"} within the folders in `data/source`.

### Omics data {.tabset}

#### MetaG {.unnumbered}

Metagenomics in the form of metagenome-assembled genomes (MAGs):

```{r download metaG, eval = F}
# --DOWNLOAD METAG DATA---------------------
fread("https://sid.erda.dk/share_redirect/dknr8GiMun/genome.count.drep.0.95.tsv.gz", check.names = T) %>%
  write.csv("data/source/omics/metaG_source.csv")
```

```{r metaG source to github, eval = F, include = F}
# metag to github
fread("https://sid.erda.dk/share_redirect/dknr8GiMun/genome.count.drep.0.95.tsv.gz", check.names = T) %>%
  write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/source/omics/metaG_source.csv")
```

------------------------------------------------------------------------

<br>

#### MetaT {.unnumbered}

Metatranscriptomics, counts of microbial gene transcripts:

```{r download metaT, eval = F}
# --DOWNLOAD METAT DATA---------------------
metat_raw <- fread("https://sid.erda.dk/share_redirect/afRGXraQCF/REF0026-c_mg-0.95.tsv.gz", check.names = T)

# extract column names
colnames(metat_raw) <- colnames(metat_raw)[[1]] %>% str_remove_all(., ".lib1") %>% str_split(., "\\.") %>% .[[1]]

# save
metat_raw %>% column_to_rownames("gene_id") %>%
  write.csv("data/source/omics/metaT_source.csv")
```

```{r metaT source to github, eval = F, include = F}
# metat to github
metat_raw %>% column_to_rownames("gene_id") %>%
  write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/source/omics/metaT_source.csv")
```

------------------------------------------------------------------------

<br>

#### MetaB {.unnumbered}

Untargeted metabolomics, abundances of compounds:

```{r download metaB, eval = F}
# from Afekta:
# https://afekta-my.sharepoint.com/personal/topi_meuronen_afekta_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Ftopi_meuronen_afekta_com%2FDocuments%2F3Domics%2C%20Swine%20proof%20of%20concept%2C%20metabolomics%20data&fromShare=true&ga=1
# s_data_with_results.xlsx saved as metaB_source.xlsx in data/source/omics
```

------------------------------------------------------------------------

<br>

#### HostT {.unnumbered}

Host transctiptomics, counts of host gene transcripts:

```{r download hostT, eval = F}
# --DOWNLOAD HOSTT DATA---------------------
fread("https://sid.erda.dk/share_redirect/gZWcEKQSTX/results/quantify/counts.tsv", check.names = T) %>%
  write.csv("data/source/omics/hostT_source.csv")
```

```{r hostT source to github, eval = F, include = F}
# hostt to github
fread("https://sid.erda.dk/share_redirect/gZWcEKQSTX/results/quantify/counts.tsv", check.names = T) %>%
  write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/source/omics/hostT_source.csv")
```

------------------------------------------------------------------------

<br>

### Metadata {.tabset}

Several types of metadata are used:

#### Sample and sequencing {.unnumbered}

Relevant experimental and technical factors of samples used to generate omic data:

```{r download sample metadata, eval = F}
# --DOWNLOAD METADATA---------------------
# sample metadata: internal AirTable -> Sample -> Experiment_C_T3-2
# https://airtable.com/app9370SI6jEJttkB/tbl0X0ElXWistmHa4/viwhAURXOZfNnolo6?blocks=hide
# saved as sample_meta_source.csv in data/source/metadata

# relate sequencing data to samples: internal AirTable -> Sequencing Macro -> grid view
# https://airtable.com/app9370SI6jEJttkB/tbl8lC1iSjZAXR9ui/viweMWIeihJFFda93?blocks=hide
# saved as sequencing_meta_source in data/source/metadata
```

------------------------------------------------------------------------

<br>

#### Trial metadata {.unnumbered}

Recorded animal weight, feed intake, and clinical scoring throughout the feeding trial:

```{r get trial meta, eval = F}
# --TRIAL INFORMATION-----------------------------
# provided by UCPH by email
# saved as trial_data_source.xlsx in data/source/metadata
```

------------------------------------------------------------------------

<br>

#### Metagenome statistics {.unnumbered}

Metadata on metagenomics data generation, including number of covered bases and genome lengths of assembled MAGs:

```{r download metaG stats, eval = F}
# --DOWNLOAD METAG STATS---------------------
# covered bases
fread("https://sid.erda.dk/share_redirect/dknr8GiMun/genome.covered_bases.drep.0.95.tsv.gz", check.names = T) %>%
  write.csv("data/source/metadata/metaG_covBases_source.csv")
```

```{r compute metaG stats, eval = F}
# genome lengths
## in HPC environment, downloaded the MAG catalogue (95% ANI) with
curl https://sid.erda.dk/share_redirect/dknr8GiMun/genome.covered_bases.drep.0.95.tsv.gz -o drep_0-95_MAG_catalogue.fa.gz --progress-bar

## created a conda environment with samtools v 1.21
conda create samtools
conda activate samtools
conda configure --add channels bioconda
conda configure -aadd channels conda-forge
conda install -c bioconda samtools
conda activate samtools

# use samtools to count num bases per MAG
samtools faidx drep_0-95_MAG_catalogue.fa.gz

# extract sequence name and length from the created index file
cut -f1-2 drep_0-95_MAG_catalogue.fa.gz.fai > metaG_contigLengths_source.csv

## save the created file reporting contig names and lengths with appropriate column names
read.csv("data/source/metadata/metaG_contigLengths_source.csv", col.names = c("contig", "length")) %>%
  write.csv("data/processed/metadata/raw_metaG_contigLengths.csv")
```

```{r metag stats to github, eval = F, include = F}
# cov bases to github
fread("https://sid.erda.dk/share_redirect/dknr8GiMun/genome.covered_bases.drep.0.95.tsv.gz", check.names = T) %>%
  write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/source/metadata/metaG_covBases_source.csv")

# contig lengths to github
read.csv("data/source/metadata/metaG_contigLengths_source.csv", row.names = 1) %>%
  write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/source/metadata/metaG_contigLengths_source.csv")
read.csv("data/processed/metadata/raw_metaG_contigLengths.csv", row.names = 1) %>%
  write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_metaG_contigLengths.csv")
```

------------------------------------------------------------------------

<br>

#### Microbial taxonomy {.unnumbered}

Taxonomic classification of MAGs:

```{r download taxonomy, eval = F}
# --DOWNLOAD TAXONOMY DATA---------------------
fread("https://sid.erda.dk/share_redirect/Dh8Xgn6rVk/gtdbtk.summary.tsv", check.names = T, na.strings = "N/A") %>% 
  write.csv("data/source/metadata/metaG_taxonomy_source.csv")
```

```{r taxonomy source to github, eval = F, include = F}
# taxonomy to github
fread("https://sid.erda.dk/share_redirect/Dh8Xgn6rVk/gtdbtk.summary.tsv", check.names = T, na.strings = "N/A") %>% 
  write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/source/metadata/metaG_taxonomy_source.csv")
```

------------------------------------------------------------------------

<br>

#### Microbial phylogenetic tree {.unnumbered}

Phylogenetic tree of assembled MAGs:

```{r download phylo tree, eval = F}
# --DOWNLOAD PHYLOGENETIC TREE---------------------
download.file("https://sid.erda.dk/share_redirect/Dh8Xgn6rVk/gtdbtk.backbone.bac120.classify.tree", "data/source/metadata/metaG_phylogenetic_source.tree")
```

```{r phylo tree source to github, eval = F, include = F}
# tree to github
download.file("https://sid.erda.dk/share_redirect/Dh8Xgn6rVk/gtdbtk.backbone.bac120.classify.tree", "/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/source/metadata/metaG_phylogenetic_source.tree")
```

------------------------------------------------------------------------

<br>

#### Microbial genome annotations {.unnumbered}

Functional annotations of MAGs:

```{r download annotations, eval = F}
# --DOWNLOAD METGENOME ANNOTATIONS ---------------------
fread("https://sid.erda.dk/share_redirect/Dh8Xgn6rVk/dram.annotations.tsv.gz", check.names = T, na.strings = "") %>% 
  write.csv("data/source/metadata/metaT_annotations_source.csv")
```

```{r annotations to github, eval = F, include = F}
# annotations to github
fread("https://sid.erda.dk/share_redirect/Dh8Xgn6rVk/dram.annotations.tsv.gz", check.names = T, na.strings = "") %>% 
  write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/source/metadata/metaT_annotations_source.csv")
```

------------------------------------------------------------------------

<br>

#### Host genome annotations {.unnumbered}

Functional annotations of the porcine genome:

```{r download host annotations, eval = F}
# --DOWNLOAD HOST GENOME ANNOTATIONS ---------------------
fread("https://ftp.ncbi.nlm.nih.gov/refseq/S_scrofa/annotation_releases/current/106/GCF_000003025.6_Sscrofa11.1/GCF_000003025.6_Sscrofa11.1_feature_table.txt.gz", check.names = T, na.strings = "") %>% 
  write.csv("data/source/metadata/hostT_annotations_source.csv")
```

```{r host annotations to github, eval = F, include = F}
# host annotations to github
fread("https://ftp.ncbi.nlm.nih.gov/refseq/S_scrofa/annotation_releases/current/106/GCF_000003025.6_Sscrofa11.1/GCF_000003025.6_Sscrofa11.1_feature_table.txt.gz", check.names = T, na.strings = "") %>% 
  write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/source/metadata/hostT_annotations_source.csv")
```

------------------------------------------------------------------------

<br>

#### Metabolomic annotations {.unnumbered}

Names of metabolite features identified in the samples:

```{r download metabolomics annotations, eval = F}
# from Afekta
# https://afekta-my.sharepoint.com/personal/topi_meuronen_afekta_com/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Ftopi_meuronen_afekta_com%2FDocuments%2F3Domics%2C%20Swine%20proof%20of%20concept%2C%20metabolomics%20data&fromShare=true&ga=1
# s_data_list_of_metabolites.xlsx saved as metaB_annotations_source in data/source/metadata
```

------------------------------------------------------------------------

<br>

## Pre-processing

### Metadata {.tabset}

First, each metadata file is processed to assume an intuitive format. The outcome files are displayed below and are included on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"} in the directory `data/processed/metadata` with the file name prefix `raw`, to indicate that they cover all features in the omic datasets before they are filtered.

<br>

#### Sample metadata {.unnumbered}

```{r raw sample meta}
# --SAMPLE INFORMATION-----------------------------
sample_meta_raw <- read.csv("data/source/metadata/sample_meta_source.csv") %>%
  # rename columns
  transmute(sample = str_c(Individual, Code),
         animal = as.integer(str_remove(Individual, "C")),
         code = Code,
         treatment = ExperimentaUnitTreatment_Series,
         type = tolower(str_replace_all(Description, " ", "_"))) %>% 
  
  # add detailed treatment info
  mutate(type = factor(type, levels = c("digesta", "mucosa", "tissue")),
         diet = factor(ifelse(treatment %in% c("TC1", "TC2", "TC4"), "AcGGM", "control"),
                       levels = c("control", "AcGGM")),
         dev_stage = factor(ifelse(treatment == "TC1", "pre-weaning",
                            ifelse(treatment %in% c("TC2", "TC4"), "post-weaning", "control")),
                            levels = c("control" , "post-weaning", "pre-weaning")),
         tag = ifelse(treatment == "TC4", "fluorescent", "none")) %>%
  
  # add sequencing ID
  left_join(read.csv("data/source/metadata/sequencing_meta_source.csv") %>% 
              mutate(seq_id = ID,
                     sample = ifelse(is.na(INsample)|INsample=="", EXsample, INsample),
                     sample = str_c(substr(sample, 1, 4), substr(sample, 6, 6)),
                     layer = ifelse(grepl("MG", DataBatch), "metaG",
                              ifelse(grepl("MT", DataBatch), "metaT",
                                ifelse(grepl("HT", DataBatch), "hostT", NA)))) %>%
              select(seq_id = ID, sample, layer), by = "sample") %>% 
  
  # keep relevant samples and columns
  filter(code %in% c("F", "G", "H", "I", "K"),
         !treatment %in% c("TC0")) %>% 
  mutate(layer = ifelse(code %in% c("I", "K"), "metaB", layer)) %>% 
  filter(!is.na(layer)) %>% 
  select(sample, animal, code, type, diet, dev_stage, tag, treatment, layer, seq_id) %>% 
  arrange(sample)
  
# preview
sample_meta_raw %>%
  pretty_table(text = "Sample information")
```

```{r save raw sample meta, eval = F, include = F}
sample_meta_raw %>% write.csv("data/processed/metadata/raw_sample_meta.csv")
sample_meta_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_sample_meta.csv")
```

------------------------------------------------------------------------

<br>

#### Trial metadata {.unnumbered}

```{r trial meta raw}
# --TRIAL INFORMATION-----------------------------
# read in
trial_meta_raw <- readxl::read_excel("data/source/metadata/trial_data_source.xlsx", na = "NA") %>% 
  # reformatting columns
  mutate(animal = as.integer(substr(animal, 2, 4)),
         date = as.Date(date),
         day = days(date)$day-19073) %>% 
  select(-animal_id)

# preview
trial_meta_raw %>% 
  pretty_table(text = "Trial data")
```

```{r save raw trial meta, eval = F, include = F}
trial_meta_raw %>% write.csv("data/processed/metadata/raw_trial_meta.csv")
trial_meta_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_trial_meta.csv")
```

------------------------------------------------------------------------

<br>

#### Metagenome coverage {.unnumbered}

```{r raw mag lengths}
# --MAG COVERAGE-----------------------------
metag_covfrac <- read.csv("data/source/metadata/metaG_covBases_source.csv", row.names = 1) %>% 
  # remove redundant samples
  select(!matches("lib1.1")) %>% 
  select(old_MAG = sequence_id, matches("D[0-9]")) %>% 
  
  # covert sample names
  pivot_longer(-old_MAG, names_to = "seq_id", values_to = "covBases") %>% 
  mutate(seq_id = str_remove(seq_id, "\\.lib1")) %>% 
  left_join(sample_meta_raw %>% select(sample, seq_id), by = "seq_id") %>% 
  select(-seq_id) %>% 
  
  # add mag lengths
  left_join(read.csv("data/processed/metadata/raw_metaG_contigLengths.csv", row.names = 1) %>%
            separate_wider_delim(contig, delim = "@", names = c("old_MAG", "contig")) %>% 
            group_by(old_MAG) %>% 
            mutate(length_MAG = sum(length)) %>% 
            ungroup() %>% distinct(old_MAG, length_MAG), by = "old_MAG") %>% 
  
  # calculate covered fraction per MAG and sample
  mutate(covFrac = covBases/length_MAG) %>% 
  select(old_MAG, sample, covFrac) %>% 
  pivot_wider(names_from = "sample", values_from = "covFrac") %>% 
  column_to_rownames("old_MAG")

# preview
metag_covfrac %>% pretty_table(text = "Metgenome-assembled genome covereed fractions (covered bases per sample and MAG divided by by total MAG length)")
```

```{r save metag covfrac, eval = F, include = F}
metag_covfrac %>% write.csv("data/processed/metadata/raw_metaG_covfrac.csv")
metag_covfrac %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_metaG_covfrac.csv")
```

------------------------------------------------------------------------

<br>

#### Taxonomy {.unnumbered}

```{r raw taxonomy}
# --MICROBIAL TAXONOMY-----------------------------
# taxonomic levels
tax_levels <- c("domain", "phylum", "class", "order", "family", "genus", "species")

# read in raw file
taxonomy_raw <- read.csv("data/source/metadata/metaG_taxonomy_source.csv") %>%
  
  # select columns
  select(old_MAG = user_genome, taxonomy = classification, ani = fastani_ani, reference = fastani_reference) %>% 
  
  # create one column per taxonomic level
  mutate(split = taxonomy) %>% 
  separate_wider_delim(split, delim = ";", too_few = "align_start", names = tax_levels) %>% 
  mutate(across(domain:species, \(x) str_remove(x, "^.__")),
         across(domain:species, \(x) str_remove(x, "_.$")),
         across(domain:species, \(x) na_if(x, ""))) %>% 
  
  # remove empty layers from summary column
  mutate(taxonomy = str_remove(str_remove(str_remove(taxonomy, ";.__$"), ";.__$"), ";.__$")) %>% 
  
  # extract most specific taxonomic identifier
  mutate(lowest = word(taxonomy, -1, sep = ";"))

taxonomy_raw %>% pretty_table(text = "Taxonomic classification of full MAG catalogue")
```

```{r save raw taxonomy, eval = F, include = F}
taxonomy_raw %>% write.csv("data/processed/metadata/raw_metaG_taxonomy.csv")
taxonomy_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_metaG_taxonomy.csv")
```

------------------------------------------------------------------------

<br>

#### Microbial phylogenetic tree {.unnumbered}

```{r raw tree}
# --MICROBIAL PHYLOGENY-----------------------------
tree_raw <- read.tree("data/source/metadata/metaG_phylogenetic_source.tree") %>% 
  # remove reference genomes from tree, leaving only MAGs
  drop.tip(.$tip.label[grepl("^.{2}_GC[AF]_", .$tip.label)])
# remove redundant quotes from tip labels
tree_raw$tip.label <- str_remove_all(tree_raw$tip.label, "\'")
```

```{r save raw tree, eval = F, include = F}
write.tree(tree_raw, "data/processed/metadata/raw_metaG_phylogenetic.tree")
write.tree(tree_raw, "/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_metaG_phylogenetic.tree")
```

------------------------------------------------------------------------

<br>

#### Microbial genome annotations {.unnumbered}

```{r raw annotations, eval = F}
# --MICROBIAL ANNOTATIONS-----------------------------
annotations_raw <- read.csv("data/source/metadata/metaT_annotations_source.csv") %>%
  # select and rename columns
  select(gene = V1,
         start_position, stop_position = end_position,
         strand = strandedness,
         ko_id:peptidase_hit, pfam_hits:cazy_best_hit) %>% 
  # streamline gene names (same delimiter between MAG, contig, and gene position parts)
  separate_wider_delim(gene, delim = "@", names = c("old_MAG", "contig_gene")) %>% 
  mutate(old_MAG = ifelse(grepl("^TC[0-9]", old_MAG), word(old_MAG, 1, 3, sep = "_"), old_MAG)) %>%
  separate_wider_delim(contig_gene, delim = "_", names = c("rm", "contig", "gene_position")) %>% 
  mutate(contig = str_c("contig", contig),
         gene_position = str_remove_all(gene_position, "_"),
         gene = str_c(old_MAG, contig, gene_position, sep = "@")) %>% 
  
  # add summary annotation column
  mutate(cazy_id = str_remove(cazy_best_hit, ".hmm"),
         annotation = ifelse(!is.na(cazy_id), cazy_id,
                      ifelse(!is.na(kegg_hit), kegg_hit,
                      ifelse(!is.na(pfam_hits), pfam_hits,
                      ifelse(!is.na(peptidase_hit), peptidase_hit, NA))))) %>% 
  # reorder columns
  select(gene, old_MAG, contig, gene_position:strand,
         annotation, ko_id:pfam_hits, cazy_id, cazy_hits)

# preview
annotations_raw %>% select(-old_MAG) %>%
  sample_n(10) %>% pretty_table(text = "Preview of ten random microbial genome annotations")
```

```{r save raw annotations, eval = F, include = F}
annotations_raw %>% write.csv("data/processed/metadata/raw_metaT_annotations.csv")
annotations_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_metaT_annotations.csv")
```

```{r read and show annot, echo = F}
# read in
annotations_raw <- read.csv("data/processed/metadata/raw_metaT_annotations.csv", row.names = 1)
# show
annotations_raw %>% select(-old_MAG) %>%
  sample_n(10) %>% pretty_table(text = str_c("Preview of ten random microbial genome annotations, from a total of ", nrow(annotations_raw), " entries."))
```

------------------------------------------------------------------------

<br>

#### Metabolite annotations {.unnumbered}

```{r raw metabolite annotations, eval = F}
# --SOURCE METAB METADATA---------------------
# read feature IDs and info
metab_annotations_raw <- readxl::read_excel("data/source/omics/metaB_source.xlsx",
                                            skip = 15, na = c("", "null")) %>% 
  # disregard count data
  select(-matches("230209ST")) %>% 
  
  # select and reorder columns
  transmute(id = Feature_ID,
         name = na_if(Metabolite_name, "Unknown"),
         formula = Formula,
         flag = tolower(Flag),
         score = Total_score, 
         adduct_type = Adduct_type,
         
         # MSMS data
         msms_spectrum = MS_MS_spectrum,
         msms_assigned = (MS_MS_assigned=="TRUE"),
         msms_matched = (MS_MS_matched=="TRUE"),
         
         # mass-to-charge ratio
         mz_avg = Average_Mz,
         mz_reference = Reference_m_z,
         mz_matched = (m_z_matched=="TRUE"),
         
         # retention time
         rt_avg_min = Average_Rt_min_, 
         rt_reference = Reference_RT,
         rt_matched = (RT_matched=="TRUE"),
         rt_similarity = RT_similarity,
         
         post_curation = Post_curation_result,
         spectrum_reference_file = Spectrum_reference_file_name,
         ms1_iso_spectrum = MS1_isotopic_spectrum) %>% 
  setNames(tolower(colnames(.))) %>% 
  
  # add curated feature names
  left_join(readxl::read_excel("data/source/metadata/metaB_annotations_source.xlsx",
                   sheet = 3, col_names = c("id", "integration", "name")), by = "id") %>%
  left_join(readxl::read_excel("data/source/metadata/metaB_annotations_source.xlsx",
                               sheet = 4, col_names = c("id")) %>%
              mutate(integration = "good_msms"), by = "id") %>% 
  
  # combine names and quality stamp
  mutate(name = ifelse(is.na(name.y), name.x, name.y),
         flag = ifelse(grepl("curated", integration.x), integration.x,
                       ifelse(grepl("ok", integration.x), "curated",
                              ifelse(is.na(integration.y), flag, integration.y)))) %>% 
  # oragnise columns
  select(id, name, formula, flag,
         score, adduct_type,
         msms_spectrum, msms_assigned, msms_matched,
         mz_avg, mz_reference, mz_matched,
         rt_avg_min, rt_reference, rt_matched, rt_similarity,
         post_curation, spectrum_reference_file, ms1_iso_spectrum)

# preview
metab_annotations_raw %>%
  filter(!is.na(name)) %>% 
  sample_n(10) %>%
  pretty_table(text = str_c("Preview of ten random metabolites, of a total ", 
                            nrow(metab_annotations_raw), " entries."))
```

```{r save raw metabolite annotations, eval = F, include = F}
metab_annotations_raw %>% write.csv("data/processed/metadata/raw_metaB_annotations.csv")
metab_annotations_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_metaB_annotations.csv")
```

```{r load and preview metab annots, echo = F}
# read in
metab_annotations_raw <- read.csv("data/processed/metadata/raw_metaB_annotations.csv", row.names = 1)
# display
metab_annotations_raw %>% 
  filter(!is.na(name)) %>% 
  sample_n(10) %>%
  pretty_table(text = str_c("Preview of ten random metabolites, of a total ", 
                            nrow(metab_annotations_raw), " entries."))
```

------------------------------------------------------------------------

<br>

#### Host genome annotations {.unnumbered}

```{r raw host annotations}
# --HOST ANNOTATIONS-----------------------------
host_annotations_raw <- read.csv("data/source/metadata/hostT_annotations_source.csv") %>%
  
  # keep genes
  filter(X..feature == "gene") %>% 
  
  # rename columns
  transmute(gene = symbol, gene_id = GeneID, description = name,
            class, seq_type, chromosome,
            start_position = start, stop_position = end,
            feature_length = feature_interval_length, product_length,
            strand = as.integer(str_replace(str_replace(strand, "\\+", "1"), "\\-", "-1")),
            locus_tag, note = attributes, genomic_accession, product_accession)

# preview
host_annotations_raw %>% filter(!is.na(description)) %>% sample_n(10) %>% pretty_table(text = str_c("Preview of ten random host genome annotations, of a total of ", nrow(host_annotations_raw), " entries."))
```

```{r save raw host annotations, eval = F, include = F}
host_annotations_raw %>% write.csv("data/processed/metadata/raw_hostT_annotations.csv")
host_annotations_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_hostT_annotations.csv")
```

------------------------------------------------------------------------

<br>

### Omics data {.tabset}

Here, each source omic data file is preprocessed to use the same format and sample naming conventions, and the tables are filtered to only report relevant data of sufficient quality. All generated files are available in the `data/processed` directory on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}, where the reformatted tables pre-filtering are prefixed `raw`.

#### Metagenomics {.unnumbered}

Reading the source file, and simplifying sample names:

```{r raw metag reformat, eval = F}
# --RAW METAG DATA: REFORMATIING----------------------
# read metaG input
metag_raw <- read.csv("data/source/omics/metaG_source.csv", row.names = 1) %>%
  
  # keep only relevant samples
  select(!matches("lib1.1")) %>% 
  select(sequence_id, matches(sample_meta_raw %>%
                                filter(tag == "none", layer == "metaG") %>%
                                pull(unique(seq_id)))) %>% 
  
  # covert sample names
  pivot_longer(-sequence_id, names_to = "seq_id", values_to = "value") %>% 
  mutate(seq_id = str_remove(seq_id, "\\.lib1")) %>% 
  left_join(sample_meta_raw %>% select(sample, seq_id), by = "seq_id") %>%
  select(-seq_id) %>% 
  
  # pivot back to MAG x sample
  pivot_wider(names_from = "sample", values_from = "value") %>% 
  column_to_rownames("sequence_id")

# preview count table
metag_raw %>%
  pretty_table(text = "Raw metagenomic counts of metagenome-assembled genome abundances (rows) across samples (columns).")
```

```{r save raw metag, eval = F, include = F}
metag_raw %>% write.csv("data/processed/omics/raw_metaG.csv")
metag_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/raw_metaG.csv")
```

```{r read raw metaG, echo = F}
# read in
metag_raw <- read.csv("data/processed/omics/raw_metaG.csv", row.names = 1)
# display
metag_raw %>%
  pretty_table(text = "Raw metagenomic counts of metagenome-assembled genome abundances (rows) across samples (columns).")
```

Filtering the metaG count table to exclude ...

-   MAGs which don't have a covered fraction over 50% in at least two samples (too uncertain)
-   MAGs which are present in only one animal (no comparison across diet groups possible)
-   samples with read counts outside 40% of mean across all MAGs (outlier samples)

```{r filter metag, message = TRUE}
# --FILTER METAGENOMICS DATA--------------------------
# covered fraction threshold
threshold_covfrac <- 0.5
threshold_sample_sd <- 0.4

# --FILTER MAGs ON COVERED FRACTION----------------------
{low_covfrac <- c()
for (r in 1:nrow(metag_covfrac)) {
  if(!sum(metag_covfrac[r,] >= threshold_covfrac) >= 2)
    low_covfrac <- c(low_covfrac, rownames(metag_covfrac)[r])
}

# notify of MAG filter result
if (length(low_covfrac) == 0) {
  message(str_c("No MAGs removed due to low covered fraction (cf < ", threshold_covfrac*100,"%)."))
} else {
  message(str_c("Removing ", sum(low_covfrac %in% rownames(metag_raw)), " of ", nrow(metag_raw),
                " MAGs due to low covered fraction (cf < ", threshold_covfrac*100,"%)."))
  metag <- metag_raw  %>%  filter(!rownames(.) %in% low_covfrac)
  }
}

# --FILTER MAGs ON PRESENCE IN JUST ONE ANIMAL----------------------
# get total abundance of each MAG across samples from each animal
{low_presence <- metag %>% 
  rownames_to_column("MAG") %>% 
  pivot_longer(matches("C[0-9]"), names_to = "sample", values_to = "value") %>% 
  mutate(animal = as.integer(substr(sample, 2, 4))) %>% 
  select(-sample) %>% 
  # keep those with no abundance
  filter(value == 0) %>% 
  group_by(MAG) %>% 
  mutate(num = max(row_number(animal))) %>% 
  
  # if less than 2 animals (total 12 - 2 = 10) have the MAG...
  filter(num > 10) %>%  
  
  # remove those from the original dataframe
  pull(MAG)

# notify of MAG filter result
if (length(low_presence) == 0) {
  message(str_c("No MAGs removed due to not being present within just one animal."))
} else {
  message(str_c("Removing ", sum(low_presence %in% rownames(metag)), " of ", nrow(metag),
                " MAGs due to presence in just one animal."))
  metag <- metag_raw  %>%  filter(!rownames(.) %in% low_presence)
  }
}


# --FILTER SAMPLES ON LOW/HIGH READ COUNTS----------------------
# find samples with read counts across all MAGs not within 50% of mean
{outlier_sample <- metag %>%
  rownames_to_column("MAG") %>% 
  pivot_longer(matches("C[0-9]"), names_to = "sample", values_to = "metag") %>% 
  group_by(sample) %>% 
  mutate(metag = sum(metag)) %>% ungroup() %>% 
  select(-MAG) %>% distinct() %>%
  mutate(lower = mean(metag)*(1-threshold_sample_sd),
         upper = mean(metag)*(1+threshold_sample_sd)) %>% 
  mutate(within = (metag>lower)&(metag<upper)) %>% 
  filter(!within) %>% pull(sample)

# remove outlier samples, notify user of filtering
if (length(outlier_sample) == 0) {
  message("No samples removed due to outlier read counts (all within mean ± ",
          threshold_sample_sd*100,"%).")
} else {
  message(str_c("Removing ", length(outlier_sample), " of ", ncol(metag), 
                " samples (", str_flatten(outlier_sample, collapse = ", "),
                ") due to outlier metaG read counts (outside mean ± ", threshold_sample_sd*100, "%)."))
  metag <- metag %>%  select(!any_of(outlier_sample))
  }
}

message(str_c("↳ Leaves ", nrow(metag), " MAGs and ", ncol(metag), " samples in the metaG table."))
```

The names of the remaining MAGs are simplified to "MAG001" through "MAG`r nrow(metag)`". The final metaG table is displayed:

```{r final metaG}
# --SIMPLIFY MAG NAMES-------------------------
# number from 001 and up according to alphabetical order of original names
new_mag_names <- data_frame(old_MAG = rownames(metag)) %>% 
  arrange(old_MAG) %>% 
  mutate(new_MAG = str_c("MAG", sprintf("%03d", row_number())))

# apply new naming scheme to metag table
metag <- metag %>% rownames_to_column("old_MAG") %>% 
  left_join(new_mag_names, by = "old_MAG") %>% 
  select(-old_MAG) %>% 
  column_to_rownames("new_MAG")

# display data
metag %>%
  pretty_table(text = "Filtered sample subset and MAG catalogue, with simplified population identifiers")
```

```{r save final metaG, eval = F, include = F}
metag %>% write.csv("data/processed/omics/metaG.csv")
metag %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/metaG.csv")
```

<br>

The same upgrade to MAG names is implemented in the microbial taxonomy metadata table, in addition to a filtering step to disregard any now-removed MAGs:

```{r final taxonomy}
# --REFINE TAXONOMY TABLE------------------
taxonomy <- taxonomy_raw %>% 
  # add new MAG names
  left_join(new_mag_names %>% select(old_MAG, new_MAG) %>% distinct(), by = "old_MAG") %>%
  select(MAG = new_MAG, taxonomy, domain:lowest, ani, reference, old_MAG) %>% 
  # filter on presence in metaG data
  filter(MAG %in% rownames(metag)) %>%
  arrange(MAG) %>% 
  # if duplicated most specific classification, numerate the entries
  group_by(lowest) %>%
  mutate(num = row_number(), max = max(num),
         num = ifelse(max == 1, NA, num)) %>% 
  ungroup() %>% 
  mutate(lowest = ifelse(is.na(num), lowest, str_c(lowest, " (", num, ")"))) %>% 
  select(-num, -max)

# remove raw taxonomy object
rm(taxonomy_raw)

# preview
taxonomy %>% pretty_table(text = "Taxonomic classifications of metagenome-assembled genomes covered in the present analysis.")
```

```{r save final taxonomy, eval = F, include = F}
taxonomy %>% write.csv("data/processed/metadata/metaG_taxonomy.csv")
taxonomy %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/metaG_taxonomy.csv")
```

The resulting taxonomy table is available in the `data/processed/metadata` directory on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}.

------------------------------------------------------------------------

<br>

#### Metatranscriptomics {.unnumbered}

Reading in the source count data and simplifying sample names:

```{r raw metaT reformat, eval = F}
# --SOURCE METAT DATA-------------------------
# read source metat data
metat_raw <- read.csv("data/source/omics/metaT_source.csv") %>%
  # simplify gene names (common delimiter between MAG, contig, and gene position)
  separate_wider_delim(X, delim = "@", names = c("MAG", "contig")) %>%
  separate_wider_delim(contig, delim = "_", names = c("rm", "contig", "genepos"), too_many = "merge") %>%
  mutate(gene = str_c(MAG, "@contig", contig, "@", genepos)) %>% 
  # keep relevant data columns
  select(gene, matches("^D[0-9]")) %>% 
  select(!starts_with(sample_meta_raw %>%
                        filter(tag!="none", layer == "metaT") %>% 
                        pull(unique(seq_id)))) %>%
  # implement sample names
  pivot_longer(-gene, names_to = "seq_id", values_to = "value") %>% 
  left_join(sample_meta_raw %>% select(seq_id, sample), by  = "seq_id") %>% 
  select(-seq_id) %>%
  # pivot back
  pivot_wider(names_from = "sample", values_from = "value") %>% 
  column_to_rownames("gene")
```

```{r save raw metaT, eval = F, include = F}
metat_raw %>% write.csv("data/processed/omics/raw_metaT.csv")
metat_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/raw_metaT.csv")
```

```{r load raw metat, echo = F}
# read in metat data
metat_raw <- read.csv("data/processed/omics/raw_metaT.csv", row.names = 1)
```

Filtering metaT data on...

-   genes of MAGs present in the dereplicated, filtered catalogue (corresponding metaG data exist)
-   genes with registered expression in at least one sample (otherwise no comparison possible)
-   samples with corresponding metaG data (disregarding redundant and outlier samples)

```{r metaT filtering, message = T}
# --FILTER METAT ON DEREPLICATED MAG CATALOGUE-------------------------
metat <- metat_raw %>%
  rownames_to_column("gene") %>% 
  # add MAG names
  mutate(to_sep = gene) %>%
  separate_wider_delim(to_sep, delim = "@", names = c("old_MAG", "old_contig", "gene_position")) %>% 
  filter(old_MAG %in% rownames(metag_raw))

# notify of filtering outcome
message(str_c("Removing ", nrow(metat_raw)-nrow(metat), " of ", nrow(metat_raw) ," genes from replicated metagenomes."))

# --FILTER METAT ON GOOD QUALITY MAGs-------------------------
old_n_genes <- nrow(metat)
metat <- metat %>% 
  left_join(new_mag_names %>% distinct(old_MAG, new_MAG), by = "old_MAG") %>% 
  
  # keep only MAGs that passed the metaG filtering
  filter(new_MAG %in% rownames(metag)) %>% 
  select(gene, matches("^C[0-9]"))

# notify of filtering outcome
message(str_c("Removing ", old_n_genes-nrow(metat), " of total ", old_n_genes ," genes due to ", nrow(metag_raw)-nrow(metag), " MAGs being of lower quality."))

# --FILTER ON EXPRESSION IN AT LEAST ONE SAMPLE---------
# get names of contigs without any observed expression
no_expression <- metat %>%
  column_to_rownames("gene") %>%
  rowSums() %>%
  data.frame(sum = .) %>% filter(sum == 0) %>% rownames()

# notify of filtering outcome
message(str_c("Removing ", length(no_expression), " of ", nrow(metat) ," genes without expression in any sample."))

# remove these entries
metat <- metat %>% filter(!gene %in% no_expression)

# --REMOVE REDUNDANT SAMPLES---------
metat <- metat %>%
  # outliers based on metaG counts
  select(!any_of(outlier_sample)) %>% 
  column_to_rownames("gene")

# notify of filtering outcome
if(length(outlier_sample)==0){message("No samples removed due to being regarded as outliers based on metaG counts.")} else {message(str_c("Removing ", length(outlier_sample), " of ", ncol(metat)+length(outlier_sample), " samples regarded as outliers based on metaG layer."))}

message(str_c("↳ Leaves ", nrow(metat), " genes and ", ncol(metat), " samples in the metaT table."))
```

Simplifying the gene names and adding MAG names to facilitate interpretation, and displaying the filtered metaT table:

```{r final metaT}
# --RENAMING GENES--------------------
new_names <- new_mag_names %>% left_join(data.frame(old_gene = rownames(metat)) %>% 
  # extract MAG, contig, and gene position names
  mutate(to_sep = old_gene) %>% 
  separate_wider_delim(to_sep, delim = "@", names = c("old_MAG", "old_contig", "gene_position")) %>% 
  mutate(gene_position = str_remove(gene_position, "_")), by = "old_MAG") %>%
  
  # numerate contigs per MAG
  group_by(old_MAG) %>%
  
  # reformat to same number of digits
  mutate(n = as.integer(factor(old_contig)),
         new_contig = ifelse(is.na(old_gene), NA, str_c("contig", sprintf("%03d", n)))) %>% 
  ungroup() %>% 
  mutate(new_gene = ifelse(is.na(new_contig), NA, str_c(new_MAG, new_contig, gene_position, sep = "_"))) %>% 
  select(old_MAG, new_MAG, old_contig, new_contig, old_gene, new_gene)

# --IMPLEMENTING NEW NAMES---------------
metat <- metat %>%
  rownames_to_column("old_gene") %>% 
  left_join(new_names %>% select(old_gene, new_gene), by = "old_gene") %>%
  column_to_rownames("new_gene") %>% 
  select(-old_gene)

# preview
metat %>% sample_n(10) %>%
  pretty_table(text = "Preview of ten random entries in the metatranscriptomic data table")
```

```{r save final metaT, eval = F, include = F}
metat %>% write.csv("data/processed/omics/metaT.csv")
metat %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/metaT.csv")
```

<br>

The updated metaT entries and gene names are integrated into the microbial annotation table, and the table is filtered to only report on genes covered by the metaT data. The final annotation table is previewed below, and may be found in the `data/processed/metadata` directory on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}.

```{r reformat annotations}
# --FILTER MICROBIAL ANNOTATIONS----------------
annotations <- annotations_raw %>%
  # filter on genes for reported MAGs, and with expression data (i.e. those with new names)
  rename_with(\(x) str_replace(x, "^gene$", "old_gene")) %>% 
  rename_with(\(x) str_replace(x, "^contig$", "old_contig")) %>% 
  left_join(new_names %>% select(old_gene, gene = new_gene, MAG = new_MAG, contig = new_contig, ), by = "old_gene") %>% 
  filter(!is.na(gene)) %>% 
  
  # add taxonomy
  left_join(taxonomy %>% select(MAG, taxonomy), by = "MAG") %>% 
  
  # move and select columns
  select(gene, taxonomy, annotation, start_position:strand, ko_id:cazy_hits,
         MAG, contig, gene_position, old_MAG, old_contig, old_gene)

# discard raw annotations object
rm(annotations_raw)

# display filtered annotations
annotations %>% sample_n(10) %>%
  pretty_table(text = "Ten random entries in the processed microbial genome annotation table")
```

```{r save final annotations, eval = F, include = F}
annotations %>% write.csv("data/processed/metadata/metaT_annotations.csv")
annotations %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/metaT_annotations.csv")
```

Hence we end up with `r nrow(annotations)` annotations across `r nrow(metat)` filtered genes for MAGs of sufficient quality, which were found expressed in at least one animal.

------------------------------------------------------------------------

<br>

#### Metabolomics {.unnumbered}

```{r raw metaB, eval = F}
# --SOURCE METAB DATA---------------------
metab_raw <- readxl::read_excel("data/source/omics/metaB_source.xlsx", skip = 15, na = "") %>% 
  # select data columns
  select(Feature_ID, matches("230209ST")) %>%
  # assign sample names to columns
  setNames(c("id", readxl::read_excel("data/source/omics/metaB_source.xlsx", range = "CC9:CY10") %>% colnames())) %>% 
  # remove redundant columns
  select(!starts_with(sample_meta_raw %>%
                        filter(tag != "none", layer == "metaB") %>%
                        pull(unique(sample)))) %>% 
  column_to_rownames("id") %>% 
  select(sort(colnames(.)))
```

```{r save raw metaB, eval = F, include = F}
metab_raw %>% write.csv("data/processed/omics/raw_metaB.csv")
metab_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/raw_metaB.csv")
```

```{r read metab, echo = F}
# read in
metab_raw <- read.csv("data/processed/omics/raw_metaB.csv", row.names = 1)
```

For the analysis, we filter the full metaB table to exclude...

-   samples made redundant due to technical complication in its preparation (C005I, C003I and K)
-   features identified in just one animal, due to no comparison being possible
-   features without curated names or sufficient identification potential using tandem mass spectrometry (MS/MS)

```{r filter metaB, message = T}
# --FILTER METAB DATA---------------------
metab <- metab_raw %>% 
  # remove redundant samples
  select(!matches("005I|003"))

message(str_c("Removing ", ncol(metab_raw)-ncol(metab)+1, " of ", ncol(metab_raw)+1, " samples due to technical complications."))


# --FILTER METABOLITES ON PRESENCE IN JUST ONE ANIMAL----------------------
# get total counts of each features across samples from each animal
{low_presence <- metab %>% 
  rownames_to_column("feature") %>% 
  pivot_longer(matches("C[0-9]"), names_to = "sample", values_to = "value") %>% 
  mutate(animal = as.integer(substr(sample, 2, 4)),
         type = substr(sample, 5, 5)) %>% 
  select(-sample) %>% 
  pivot_wider(names_from = "type", values_from = "value") %>% 
  mutate(across(`I`:`K`, \(x) replace_na(x, 0)),
         sum = `I`+`K`) %>% 
  # keep those with no abundance
  filter(sum == 0) %>% 
  group_by(feature) %>% 
  mutate(num = max(row_number(animal))) %>% 
  
  # if less than 2 animals (total 8 - 2 = 6) have the features
  filter(num > 6) %>%  
  
  # remove those from the original dataframe
  pull(feature)

# notify of meatbolite filter result
if (length(low_presence) == 0) {
  message(str_c("No metabolites removed due to not being present within just one animal."))
} else {
  message(str_c("Removing ", sum(low_presence %in% rownames(metab)), " of ", nrow(metab),
                " metabolites due to presence in just one animal."))
  metab <- metab  %>%  filter(!rownames(.) %in% low_presence)
  }
}


# --FILTER METABOLITES ON IDENTIFICATION STATUS----------------------
# filter on entries with curated names, or potential for curation
metab_annotations <- metab_annotations_raw %>% filter(flag %in% c("curated", "good_msms"))

# notify of filter outcome
message(str_c("Removing ", nrow(metab_annotations_raw)-nrow(metab_annotations), " of ",
              nrow(metab_annotations_raw), " metabolites with low detection quality."))

# remove entries from count table
metab <- metab %>% filter(rownames(.) %in% (metab_annotations_raw %>%
                                              filter(flag %in% c("curated", "good_msms")) %>% pull(id)))

message(str_c("↳ Leaves ", nrow(metab), " metabolites and ", ncol(metab), " samples (", ncol(metab %>% select(matches("[0-9]I"))), " digesta, ", ncol(metab %>% select(matches("[0-9]K"))), " tissue) in the metaB table."))
```

```{r save final metaB, eval = F, include = F}
# local
metab %>% write.csv("data/processed/omics/metaB.csv")
metab_annotations %>% write.csv("data/processed/metadata/metaB_annotations.csv")

# to github
metab %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/metaB.csv")
metab_annotations %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/metaB_annotations.csv")

# remove raw annotations object
rm(metab_annotations_raw)
```

The filtered feature table and their annotations are included in the folders `omics` and `metadata` within the `data/processed` directory on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}. Both tables are previewed below:

```{r final metaB}
# 20 random metabolites
tmp <- metab %>% sample_n(20) %>% rownames()

# preview metaB table
metab[tmp,] %>% pretty_table(text = "Preview of 20 random entries in the metabolomics count table")

# preview metaB annotations
metab_annotations %>% column_to_rownames("id") %>% 
  .[tmp,] %>% rownames_to_column("id") %>% 
  pretty_table(text = "Accompanying metadata for the 20 random entries in the metabolomics count table displayed above")
```

------------------------------------------------------------------------

<br>

#### Host transcriptomics {.unnumbered}

Reading in the raw count table and fetching sample names:

```{r raw hostT}
# --SOURCE HOST TRANSCRIPTOMICS DATA------------
hostt_raw <- read.csv("data/source/omics/hostT_source.csv") %>% select(-X) %>%
  
  # substitute sequencing IDs with sample names
  pivot_longer(matches(".[0-9]"), names_to = "seq_id", values_to = "value") %>% 
  mutate(seq_id = word(seq_id, 1, sep = fixed("."))) %>% 
  left_join(sample_meta_raw %>% select(sample, seq_id), by = "seq_id") %>% 
  select(-seq_id) %>%
  
  # pivot back
  arrange(sample) %>% 
  pivot_wider(names_from = "sample", values_from = "value") %>% 
  column_to_rownames("gene_id") %>% 
  
  # remove redundant samples
  select(!starts_with(sample_meta_raw %>%
                        filter(tag != "none") %>% pull(sample) %>% unique()))
```

```{r save raw hostT, eval = F, include = F}
hostt_raw %>% write.csv("data/processed/omics/raw_hostT.csv")
hostt_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/raw_hostT.csv")
```

The hostT table is filtered to exclude outlier samples and genes without registered expression in any sample:

```{r filter hostT, message = T}
# --FILTER ON EXPRESSION IN AT LEAST ONE SAMPLE---------
# get names of contigs without any observed expression
no_expression <- hostt_raw %>%
  rowSums() %>%
  data.frame(sum = .) %>% filter(sum == 0) %>% rownames()

# notify of filtering step
message(str_c("Removing ", length(no_expression), " of ", nrow(hostt_raw) ," host genes without expression in any sample."))

# remove these entries
hostt <- hostt_raw %>% filter(!rownames(.) %in% no_expression)

# sample filtering
# remove outlier sample based on previous finds, notify user of filtering
if (length(outlier_sample) == 0) {
  message("No samples removed due to outlier read counts (all within mean ± ",
          threshold_sample_sd*100,"%).")
} else {
  tmp_outlier_sample <- lapply(outlier_sample, \(x) str_replace(x, "F", "H")) %>% unlist()
  message(str_c("Removing ", length(tmp_outlier_sample), " of ", ncol(hostt), 
                " samples (", str_flatten(tmp_outlier_sample, collapse = ", "),
                ") regarded as outliers based on previous omic layers."))
  hostt <- hostt %>%  select(!any_of(tmp_outlier_sample))
  }
rm(tmp_outlier_sample)

# notify of outcome
message(str_c("↳ Leaves ", nrow(hostt), " genes and ", ncol(hostt), " samples in the hostT table."))
```

The host genome annotation table is filtered to cover only the genes remaining in the hostT dataset:

```{r filter host annotations}
# --HOST GENOME ANNOTATIONS--------------------
# source table
host_annotations_raw <- read.csv("data/processed/metadata/raw_hostT_annotations.csv") %>% select(-X)

# keep entries for genes in the count table
{host_annotations <- host_annotations_raw %>% 
  filter(gene %in% rownames(hostt))

# add empty entries for genes without annotations
host_annotations <- host_annotations %>% 
  rbind(data.frame(gene = rownames(hostt)[(!(rownames(hostt) %in% host_annotations$gene))],
        gene_id = NA, description = NA, class = NA, seq_type = NA, chromosome = NA,
        start_position = NA, stop_position = NA, feature_length = NA, product_length = NA,
        strand = NA, locus_tag = NA, note = "not in ncbi",
        genomic_accession = NA, product_accession = NA))}
```

The final host gene table and their annotations are included in the `omics` and `metadata` directories within the folder `data/processed` on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}. Excerpts of both tables are included below:

```{r save final hostT, eval = F, include = F}
# local
hostt %>% write.csv("data/processed/omics/hostT.csv")
host_annotations_raw %>% write.csv("data/processed/metadata/raw_hostT_annotations.csv")
host_annotations %>% write.csv("data/processed/metadata/hostT_annotations.csv")

# github
hostt %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/hostT.csv")
host_annotations_raw %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/raw_hostT_annotations.csv")
host_annotations %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/hostT_annotations.csv")
```

```{r remove raw host, echo = F}
# remove raw host annotations object
rm(host_annotations_raw)
```

```{r final hostT}
# --PREVIEW HOSTT DATA---------------------------
# random selection of 20 genes
tmp <- hostt %>% sample_n(20) %>% rownames()

# preview count data
hostt[tmp,] %>% arrange(rownames(.)) %>% 
  pretty_table(text = "Preview of expression levels of 20 random host genes across samples")

# preview genome annotations
host_annotations %>% filter(gene %in% tmp) %>% arrange(gene) %>%
  pretty_table(text = "Accompanying metadata for the genes in the host transcriptomics count table displayed above")
```

<br>

Lastly, we filter the trial data and sample information tables to include only animals and samples covered by the final metaG, metaT, metaB, and hostT data layers. The final overview is displayed below:

```{r filter trial and sample meta}
# --FILTER TRIAL AND SAMPLE INFORMATION------------
# include just rows representing samples that passed quality filtering
sample_meta <- sample_meta_raw %>% select(-seq_id) %>% distinct() %>% 
  filter(sample %in% unique(c(colnames(metag), colnames(metat),
                              colnames(metab), colnames(hostt)))) %>%
  select(-tag) %>% 
  arrange(sample)

trial_meta <- trial_meta_raw %>%
  filter(animal %in% sample_meta$animal)

# previews
trial_meta %>% pretty_table(text = "Details on the animals during the trial, including weight, feed intake, and clinical scores.")
sample_meta %>% pretty_table(text = "Details on the animals, treatments, and extraction of samples used to generate omics data")
```

```{r final sample meta, eval = F, include = F}
trial_meta %>% write.csv("data/processed/metadata/trial_meta.csv")
trial_meta %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/trial_meta.csv")

sample_meta %>% write.csv("data/processed/metadata/sample_meta.csv")
sample_meta %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/sample_meta.csv")
```

All data tables and metadata required for the present analysis are now available in the R environment.

```{r}
# --DESCRIPTIVE STATISTICS: MULTI-OMIC DATASET---------------
# count num. samples and features for each omic layer
data.frame(layer = c("metagenomics", "metatranscriptomics",
                     "metabolomics (digesta)", "metabolomics (tissue)", "host transcriptomics"),
           n_samples = c(ncol(metag), ncol(metat),
                         ncol(metab %>% select(contains("I"))),
                         ncol(metab %>% select(contains("K"))), ncol(hostt)),
           n_features = c(nrow(metag), nrow(metat),
                          nrow(metab %>% select(contains("I"))),
                          nrow(metab %>% select(contains("K"))), nrow(hostt))) %>% 
  # calculate percentages
  mutate(`%_features` = round(n_features/sum(n_features)*100, 2)) %>% 
  arrange(desc(`%_features`)) %>% 
  # add total line
  rbind(data.frame(layer = "TOTAL",
                   n_samples = sum(.$n_samples),
                   n_features = sum(.$n_features),
                   `%_features` = sum(.$`%_features`), check.names = F)) %>% 
  
  pretty_table(text = "Number of samples and features in each omic layer.")
```

------------------------------------------------------------------------

<br>

## Colour scheme

Defining a colour scheme used in data visualisations throughout the report:

```{r colour scheme, eval = F}
# --COLOUR SCHEME---------------------
# sample details
annot_colours <- list(type = c(digesta = "pink",
                               tissue = "tan"),
                      
                      diet = c(control = "grey90",
                               AcGGM = "#8EC286"),
                      
                      dev_stage = c(control = "grey90",
                                    `post-weaning` = "darkseagreen2",
                                    `pre-weaning` = "palegreen4"))
# microbial taxonomy
for(level in tax_levels){
  annot_colours[[level]] <- taxonomy %>% select(all_of(level)) %>%
    distinct() %>% nrow() %>% get_colours()
  names(annot_colours[[level]]) <- taxonomy %>% select(all_of(level)) %>%
    distinct() %>% pull(1) %>% sort()
}
```

```{r save colour scheme, eval = F, include = F}
# save this palette to get same taxonomy colourations each time the report is knitted
save(annot_colours, file = "data/processed/metadata/annot_colours.RData")
# github
save(annot_colours, file = "/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/annot_colours.RData") 
```

```{r load colour scheme, echo = F}
# load premade colour palette for consistent taxonomy colouration in manuscript and report
load("data/processed/metadata/annot_colours.RData")
```

```{r fig.width = 16, fig.height = 3, echo = F, out.width="40%"}
data.frame(category = c("sample type", "sample type",
                        "diet group", "diet group",
                        "dev. stage", "dev. stage", "dev. stage"),
           variable = c("digesta", "tissue",
                        "control", "AcGGM",
                        "control", "post-weaning", "pre-weaning"),
           colour = c(annot_colours$type[["digesta"]],
                      annot_colours$type[["tissue"]],
                      annot_colours$diet[["control"]],
                      annot_colours$diet[["AcGGM"]],
                      annot_colours$dev_stage[["control"]],
                      annot_colours$dev_stage[["post-weaning"]],
                      annot_colours$dev_stage[["pre-weaning"]])
           ) %>% 
  mutate(across(everything(), \(x) factor(x, levels = unique(x)))) %>% 
  group_by(category) %>% 
  mutate(x = as.integer(category),
         y = seq_along(category)) %>% 
  
  ggplot() +
  geom_point(aes(category, y, fill = colour), shape = 22, size = 18, stroke = 0.5) +
  geom_text(aes(category, y, label = variable), size = 9,
            vjust = 0.5, hjust = 0, nudge_x = 0.1) +
  
  scale_fill_identity() +
  scale_y_reverse(expand = c(0.4, 0)) +
  scale_x_discrete(position = "top",
                  expand = c(0, 0.1),
                  breaks = c("sample type", "diet group", "dev. stage"),
                  limits = c("sample type", "diet group", "dev. stage", ""), drop = F) +
  
  theme(plot.background = element_blank(),
        panel.background = element_blank(),
        
        axis.text.y = element_blank(),
        axis.text.x = element_text(size = 32, hjust = 0.1, colour = "black"),
        
        axis.title = element_blank(),
        axis.ticks = element_blank())
```

<br>

# Data standardisation {.tabset}

Here, each omic dataset is processed to facilitate integrated analysis. Namely, metabolomic count data are log2-transformed, and read counts are applied a variance-stabilising transformation (VST) using the package DESeq (ver. 1.46.0) [[@love2016]]. This package is also used to conduct differential abundance and expression analyses on the metagenomic and the two transcriptomic data layers, respectively. The DESeq analysis enables comparison of read counts across samples through estimating dispersion and size factors for each feature (MAGs or genes), which are normalisation steps that account for within-sample variability and between-sample variation due to varying library sizes. These steps ensure that the data is comparable both within and between samples. DESEq then fits a negative binomial model to the input data and tests whether the observed counts differ between groups of samples as defined by metadata provided to the algorithm. Specifically for the present datasets, samples may be divided in two `diet` groups depending on whether AcGGM was given as a dietary supplement ("control" or "AcGGM"); or into three `dev_stage` groups according to when the pigs were first introduced to the fibre ("control", "post-weaning", or "pre-weaning"). For metabolomics, we may additionally differentiate between samples of separate `types` ("digesta" and "tissue"), which we associated with each side of the porcine holobiont system.

In the following subsections, separate data objects are created for each omic layer and contrast, and significant differences between sample subsets are identified. Thresholds for signficance are set to absolute log2 fold change (LFC) above 1, false discovery rate-adjusted (FDR) p-value below 0.05, and base mean above 50.

```{r significance thresholds}
# --SIGNIFICANCE THRESHOLDS--------------
threshold_lfc <- 1
threshold_padj <- 0.05
threshold_baseMean <- 50
```

The standardised datasets are all available in the `data/processed/omics` directory on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"} as files with `_vst` or \_`log2` suffixes. Significant results from the differential abundance and expression analyses are included in the directory `results`.

## Metagenomics {.unnumbered}

The metaG data may be used to compare microbial community compositions across samples of different `diet` groups and `dev_stage` for AcGGM inclusion start.

```{r metaG differential abundance analysis, eval = F}
# --METAG DATA DESEQ OBJECTS------------------------
# DIET GROUP (control vs. AcGGM)
# create deseq object
{metag_dds_diet <- metag %>%
  DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "metaG"),
                         design = ~diet)
# ensure correct reference level is used
metag_dds_diet$diet <- relevel(metag_dds_diet$diet, ref = "control")

# run analysis
metag_dds_diet <- metag_dds_diet %>% DESeq()}

# extract results
metag_daa_diet <- metag_dds_diet %>%
  results(contrast = c("diet", "AcGGM", "control")) %>%
  as.data.frame() %>% rownames_to_column("MAG") %>% 
  mutate(category = "diet", contrast = "control_v_AcGGM")

# extract significant results
metag_daa_diet_signif <- metag_daa_diet %>% 
  filter(abs(log2FoldChange) > threshold_lfc,
         padj < threshold_padj,
         baseMean > threshold_baseMean)


# ----------------------------------
# DEVELOPMENT STAGE (control vs. post- vs. pre-weaning)
# create deseq object
{metag_dds_devstage <- metag %>%
  DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "metaG"),
                           design = ~dev_stage)
# ensure correct reference level is used
metag_dds_devstage$dev_stage <- relevel(metag_dds_devstage$dev_stage, ref = "control")

# run analysis
metag_dds_devstage <- metag_dds_devstage %>% DESeq()}

# extract results
  ## control vs. pre-weaning
metag_daa_devstage <- results(metag_dds_devstage, contrast = c("dev_stage", "pre-weaning", "control")) %>%
  as.data.frame() %>% rownames_to_column("MAG") %>% 
  mutate(category = "dev_stage", contrast = "control_v_pre-weaning") %>% 
  ## control vs. post-weaning
  rbind(results(metag_dds_devstage, contrast = c("dev_stage", "post-weaning", "control")) %>%
  as.data.frame() %>% rownames_to_column("MAG") %>% 
  mutate(category = "dev_stage", contrast = "control_v_post-weaning")) %>% 
  ## pre- vs. post-weaning
  rbind(results(metag_dds_devstage, contrast = c("dev_stage", "pre-weaning", "post-weaning")) %>%
  as.data.frame() %>% rownames_to_column("MAG") %>% 
  mutate(category = "dev_stage", contrast = "post-weaning_v_pre-weaning"))

# extract significant results
metag_daa_devstage_signif <- metag_daa_devstage %>% 
  filter(abs(log2FoldChange) > threshold_lfc,
         padj < threshold_padj,
         baseMean > threshold_baseMean)


# --APPLY VST---------------------------------
metag_vst <- metag %>%
  DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "metaG"),
                           design = ~diet) %>% 
  varianceStabilizingTransformation() %>% 
  assay() %>% as.data.frame()


# --COMBINE METAG DIFFERENTIAL ABUNDANCE TEST RESULTS-----------------
# all 
metag_daa <- metag_daa_diet %>% rbind(metag_daa_devstage) %>% 
  left_join(taxonomy %>% select(MAG, lowest, taxonomy), by = "MAG") %>% 
  select(category, contrast, MAG, lowest, taxonomy, log2FoldChange, padj, baseMean)

# significant
metag_daa_signif <- metag_daa_diet_signif %>%
  rbind(metag_daa_devstage_signif) %>%
  # facilitate significance bar plotting
  ## add taxonomy
  left_join(taxonomy %>% select(MAG, taxonomy, phylum, lowest), by = "MAG") %>% 
  ## create labels
  mutate(label = str_c(MAG, ": ", "p__", phylum, "\n", lowest),
         bar_start = word(contrast, 1, sep  = "_"),
         bar_stop = word(contrast, 3, sep = "_"),
         across(bar_start:bar_stop, \(x) factor(x,
                        levels = c("control", "AcGGM", # diet group
                                   "pre-weaning", "post-weaning"))), # devstage
         bar_label = str_c(round(log2FoldChange, 2), " ",
                        ifelse(padj < 0.001, "***", ifelse(padj < 0.01, "**", "*")))) %>% 
  ## define y coordinate just above highest observed read count value
  group_by(MAG, category) %>% 
  rowwise() %>% 
  mutate(bar_y = metag_vst[MAG,] %>% max(),
         bar_y = ifelse(contrast == "control_v_pre-weaning",
                        bar_y * 1.15, bar_y * 1.05)) %>% 
  ungroup() %>% 
  select(category, contrast, MAG, phylum, lowest, taxonomy,
         log2FoldChange, padj, baseMean, label, bar_start:bar_y)

# remove intermediate objects
rm(metag_dds_diet, metag_dds_devstage,
   metag_daa_diet, metag_daa_devstage,
   metag_daa_diet_signif, metag_daa_devstage_signif)
```

```{r save metag results, eval = F, include = F}
# local
metag_vst %>% write.csv("data/processed/omics/metaG_vst.csv")
metag_daa %>% write.csv("results/diff_abundance_expression/metaG_diff_abundance.csv")
metag_daa_signif %>% write.csv("results/diff_abundance_expression/metaG_sign_diff_abundance.csv")

# save to github
metag_vst %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/metaG_vst.csv")
metag_daa %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/results/diff_abundance_expression/metaG_diff_abundance.csv")
metag_daa_signif %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/results/diff_abundance_expression/metaG_sign_diff_abundance.csv")
```

```{r load metag daa result data, echo = F}
# load results
metag_vst <- read.csv("data/processed/omics/metaG_vst.csv", row.names = 1)
metag_daa <- read.csv("results/diff_abundance_expression/metaG_diff_abundance.csv") %>% select(-X)
metag_daa_signif <- read.csv("results/diff_abundance_expression/metaG_sign_diff_abundance.csv") %>% select(-X)
```

------------------------------------------------------------------------

<br>

## Metatranscriptomics {.unnumbered}

The metaT data may be used to compare the transcriptional activity of microbial community members across samples of different `diet` groups and `dev_stage` for AcGGM inclusion start.

```{r metaT differential expression analysis, eval = F}
# --METAT DATA DESEQ OBJECTS------------------------
# DIET GROUP (control vs. AcGGM)
# create deseq object
{metat_dds_diet <- metat %>%
  DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "metaT"),
                           design = ~diet)
# ensure correct reference level is used
metat_dds_diet$diet <- relevel(metat_dds_diet$diet, ref = "control")

# run analysis
metat_dds_diet <- metat_dds_diet %>% DESeq()}

# extract results
metat_dea_diet <- metat_dds_diet %>%
  results(contrast = c("diet", "AcGGM", "control")) %>% as.data.frame() %>% 
  rownames_to_column("gene") %>% 
  mutate(category = "diet", contrast = "control_v_AcGGM")

# extract significant results
metat_dea_diet_signif <- metat_dea_diet %>%
  filter(abs(log2FoldChange) > threshold_lfc,
         # baseMean > threshold_baseMean,
         padj < threshold_padj)


# ----------------------------------
# DEVELOPMENT STAGE (control vs. post- vs. pre-weaning)
# create deseq object
{metat_dds_devstage <- metat %>%
  DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "metaT"),
                           design = ~dev_stage)
# ensure correct reference level is used
metat_dds_devstage$dev_stage <- relevel(metat_dds_devstage$dev_stage, ref = "control")

# run analysis
metat_dds_devstage <- metat_dds_devstage %>% DESeq()}

# extract results
metat_dea_devstage <- results(metat_dds_devstage, contrast = c("dev_stage", "pre-weaning", "control")) %>%
  as.data.frame() %>% rownames_to_column("gene") %>% 
  mutate(category = "dev_stage", contrast = "control_v_pre-weaning") %>% 
  ## control vs. post-weaning
  rbind(results(metat_dds_devstage, contrast = c("dev_stage", "post-weaning", "control")) %>%
  as.data.frame() %>% rownames_to_column("gene") %>% 
  mutate(category = "dev_stage", contrast = "control_v_post-weaning")) %>% 
  ## pre- vs. post-weaning
  rbind(results(metat_dds_devstage, contrast = c("dev_stage", "pre-weaning", "post-weaning")) %>%
  as.data.frame() %>% rownames_to_column("gene") %>% 
  mutate(category = "dev_stage", contrast = "post-weaning_v_pre-weaning"))

# extract significant results
metat_dea_devstage_signif <- metat_dea_devstage %>%
  filter(abs(log2FoldChange) > threshold_lfc,
         # baseMean > threshold_baseMean,
         padj < threshold_padj)
  

# --APPLY VST---------------------------------
metat_vst <- metat %>%
    DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "metaT"),
                           design = ~diet) %>%
  varianceStabilizingTransformation() %>% 
  assay() %>% as.data.frame()


# --COMBINE METAT DIFFERENTIAL EXPRESSION TEST RESULTS-----------------
metat_dea <- metat_dea_diet %>% 
  rbind(metat_dea_devstage) %>% 
  # add MAG names
  left_join(annotations %>% distinct(MAG, gene, annotation), by = "gene") %>%
  mutate(MAG = ifelse(is.na(MAG), word(gene, 1, sep = "_"), MAG)) %>% 
  # add taxonomy
  left_join(taxonomy %>% select(MAG, lowest, taxonomy), by = "MAG") %>% 
  # mark significant differences
  mutate(signif = ifelse(abs(log2FoldChange) > 1 & padj < 0.05, "*", NA)) %>% 
  select(category, contrast, MAG, lowest, taxonomy, gene, annotation,
         log2FoldChange, padj, baseMean, signif)

metat_dea_signif <- metat_dea_diet_signif %>% 
  rbind(metat_dea_devstage_signif) %>% 
  # facilitate significance bar plotting
  ## add MAG names
  left_join(annotations %>% distinct(MAG, gene, annotation), by = "gene") %>% 
  mutate(MAG = ifelse(is.na(MAG), word(gene, 1, sep = "_"), MAG)) %>% 
  ## add taxonomy
  left_join(taxonomy %>% select(MAG, phylum, lowest, taxonomy), by = "MAG") %>% 
  ## create labels
  mutate(label = str_c(MAG, ": ", "p__", phylum, "\n", lowest, "\n",
                       word(gene, 2, 3, sep = "_"),
                       ifelse(is.na(annotation), " (not annotated", str_c(": ", annotation))),
         bar_start = word(contrast, 1, sep  = "_"),
         bar_stop = word(contrast, 3, sep = "_"),
         across(bar_start:bar_stop, \(x) factor(x,
                                                levels = c("control", "AcGGM", # diet group
                                                           "pre-weaning", "post-weaning"))), # devstage
         bar_label = str_c(round(log2FoldChange, 2), " ",
                           ifelse(padj < 0.001, "***", ifelse(padj < 0.01, "**", "*")))) %>% 
  ## define y coordinate just above highest observed read count value
  group_by(gene, category) %>% 
  rowwise() %>% 
  mutate(bar_y = metat_vst[gene,] %>% max(),
         # prevent overlapping by pushing one bar up slightly
         bar_y = ifelse(contrast == "control_v_pre-weaning",
                        bar_y * 1.15, bar_y * 1.05)) %>% 
  ungroup() %>% 
  select(category, contrast, MAG, lowest, taxonomy, gene, annotation,
         log2FoldChange, padj, baseMean, label, bar_start:bar_y) %>% 
  distinct()

# remove intermediate objects
rm(metat_dds_diet, metat_dds_devstage,
   metat_dea_diet, metat_dea_devstage,
   metat_dea_diet_signif, metat_dea_devstage_signif)
```

```{r save metat results, eval = F, include = F}
# diff expr objects
save(metat_dds_diet, file = "results/diff_abundance_expression/metaT_dds_diet.R")
save(metat_dds_devstage, file = "results/diff_abundance_expression/metaT_dds_devStage.R")
save(metat_dea_signif, file = "results/diff_abundance_expression/metaT_dea_signif.R")

# local files
metat_vst %>% write.csv("data/processed/omics/metaT_vst.csv")
metat_dea %>% write.csv("results/diff_abundance_expression/metaT_diff_expression.csv")
metat_dea_signif %>% write.csv("results/diff_abundance_expression/metaT_sign_diff_expression.csv")

# save to github
metat_vst %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/metaT_vst.csv")
metat_dea %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/results/diff_abundance_expression/metaT_diff_expression.csv")
metat_dea_signif %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/results/diff_abundance_expression/metaT_sign_diff_expression.csv")
```

```{r load metat dea result data, echo = F}
# load results
metat_vst <- read.csv("data/processed/omics/metaT_vst.csv", row.names = 1)
metat_dea <- read.csv("results/diff_abundance_expression/metaT_diff_expression.csv") %>% select(-X)
metat_dea_signif <- read.csv("results/diff_abundance_expression/metaT_sign_diff_expression.csv") %>% select(-X)
```

------------------------------------------------------------------------

<br>

## Metabolomics {.unnumbered}

Untargeted metabolomics data were generated from both digesta and tissue sample `types`, for animals given different `diets`, and with AcGGM inclusion starting at different `development stage`. Hence separate LFC calculations and tests for significant difference - through a two-tailed t-test assuming equal variance between sample groups - are run for each metabolite and contrast.

```{r metaB differential abundance analysis type, eval = F}
# --METABOLOMICS STANDARDISATION---------------
# log2 transform counts
metab_log2 <- metab %>% log2()

# --------------------------------
# SAMPLE TYPE (digesta vs. tissue)
# split on sample type
metab_digesta <- metab %>%
  select(any_of(sample_meta %>% filter(type == "digesta") %>% pull(sample)))
metab_tissue <- metab %>%
  select(any_of(sample_meta %>% filter(type == "tissue") %>% pull(sample)))

# t-test of each metabolite. if all missing values, set pvalue to NA
metab_type_pvalue <- c()
{for(r in 1:nrow(metab)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_digesta %>% .[r,], 
                    metab_tissue %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){ 
      tmp <- NA
    },
    finally = {
      metab_type_pvalue <- c(metab_type_pvalue, tmp)
    }
  )
}}

# assemble sample type difference test results
metab_daa_type <- data.frame(digesta_mean = metab_digesta %>% rowMeans(na.rm = T),
                             tissue_mean = metab_tissue %>% rowMeans(na.rm = T)) %>% 
  # calculte LFC (log2 of difference in mean for each metabolite per sample group)
  mutate(log2FoldChange = log2(tissue_mean/digesta_mean)) %>% 
  # add p-values
  cbind(pvalue = metab_type_pvalue) %>% 
  rownames_to_column("id") %>% 
  mutate(padj = p.adjust(pvalue, method = "fdr"),
         category = "type", type = "all", contrast = "digesta_v_tissue")
```

```{r metaB differential abundance analysis diet, eval = F}
# DIET GROUP (control vs. AcGGGM)
# --both sample types-------------------
# split metabolite data according to diet
metab_all_control <- metab %>%
  select(any_of(sample_meta %>% filter(diet == "control") %>% pull(sample)))
# disregard fluorescent AcGGM-fed animals
metab_all_acggm <- metab %>%
  select(any_of(sample_meta %>% filter(diet == "AcGGM") %>% pull(sample)))

# t-test of each metabolite. if all missing values, set pvalue to NA
{metab_all_diet_pvalue <- c()
for(r in 1:nrow(metab)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_all_control %>% .[r,], 
                    metab_all_acggm %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_all_diet_pvalue <- c(metab_all_diet_pvalue, tmp)
    }
  )
}}

# assemble diet group difference test results
metab_all_daa_diet <- data.frame(control_mean = metab_all_control %>% rowMeans(na.rm = T),
                             acggm_mean = metab_all_acggm %>% rowMeans(na.rm = T)) %>% 
  # calculte LFC (log2 of difference in mean for each metabolite per sample group)
  mutate(log2FoldChange = log2(acggm_mean/control_mean)) %>% 
  # add p-values
  cbind(pvalue = metab_all_diet_pvalue) %>% 
  rownames_to_column("id") %>% 
  mutate(padj = p.adjust(pvalue, method = "fdr"),
         category = "diet", type = "all", contrast = "control_v_AcGGM")


# --digesta samples-------------------
# split metabolite data according to diet
metab_digesta_control <- metab_digesta %>% select(any_of(sample_meta %>% filter(diet == "control") %>% pull(sample)))
metab_digesta_acggm <- metab_digesta %>% select(any_of(sample_meta %>% filter(diet == "AcGGM") %>% pull(sample)))

# t-test of each metabolite. if all missing values, set pvalue to NA
{metab_digesta_diet_pvalue <- c()
for(r in 1:nrow(metab_digesta)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_digesta_control %>% .[r,], 
                    metab_digesta_acggm %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_digesta_diet_pvalue <- c(metab_digesta_diet_pvalue, tmp)
    }
  )
}}

# assemble diet group difference test results
metab_digesta_daa_diet <- data.frame(control_mean = metab_digesta_control %>% rowMeans(na.rm = T),
                             acggm_mean = metab_digesta_acggm %>% rowMeans(na.rm = T)) %>% 
  # calculte LFC (log2 of difference in mean for each metabolite per sample group)
  mutate(log2FoldChange = log2(acggm_mean/control_mean)) %>% 
  # add p-values
  cbind(pvalue = metab_digesta_diet_pvalue) %>% 
  rownames_to_column("id") %>% 
  mutate(padj = p.adjust(pvalue, method = "fdr"),
         category = "diet", type = "digesta", contrast = "control_v_AcGGM")


# --tissue samples-------------------
# split metabolite data according to diet
metab_tissue_control <- metab_tissue %>% select(any_of(sample_meta %>% filter(diet == "control") %>% pull(sample)))
metab_tissue_acggm <- metab_tissue %>% select(any_of(sample_meta %>% filter(diet == "AcGGM") %>% pull(sample)))

# t-test of each metabolite. if all missing values, set pvalue to NA
{metab_tissue_diet_pvalue <- c()
for(r in 1:nrow(metab_tissue)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_tissue_control %>% .[r,], 
                    metab_tissue_acggm %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_tissue_diet_pvalue <- c(metab_tissue_diet_pvalue, tmp)
    }
  )
}}

# assemble diet group difference test results
metab_tissue_daa_diet <- data.frame(control_mean = metab_tissue_control %>% rowMeans(na.rm = T),
                             acggm_mean = metab_tissue_acggm %>% rowMeans(na.rm = T)) %>% 
  # calculte LFC (log2 of difference in mean for each metabolite per sample group)
  mutate(log2FoldChange = log2(acggm_mean/control_mean)) %>% 
  # add p-values
  cbind(pvalue = metab_tissue_diet_pvalue) %>% 
  rownames_to_column("id") %>% 
  mutate(padj = p.adjust(pvalue, method = "fdr"),
         category = "diet", type = "tissue", contrast = "control_v_AcGGM")
```

```{r metaB differential abundance analysis devstage, eval = F}
# DEVELOPMENTAL STAGE (control vs. post- vs. pre-weaning)
# --both sample types--------------------
# split metabolite data according to AcGGM inclusion stage
metab_all_postWeaning <- metab %>% select(any_of(sample_meta %>% filter(dev_stage == "post-weaning") %>% pull(sample)))
metab_all_preWeaning <- metab %>% select(any_of(sample_meta %>% filter(dev_stage == "pre-weaning") %>% pull(sample)))

# t-test of each metabolite. if all missing values, set pvalue to NA
{metab_all_devstage_pvalue <- list(control_v_post = c(),
                                   control_v_pre = c(),
                                   post_v_pre = c())
## control vs. post-weaning
for(r in 1:nrow(metab)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_all_control %>% .[r,], 
                    metab_all_postWeaning %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_all_devstage_pvalue$control_v_post <- c(metab_all_devstage_pvalue$control_v_post, tmp)
    }
  )
}
## control vs. pre-weaning
for(r in 1:nrow(metab)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_all_control %>% .[r,], 
                    metab_all_preWeaning %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_all_devstage_pvalue$control_v_pre <- c(metab_all_devstage_pvalue$control_v_pre, tmp)
    }
  )
}
## post- vs. pre-weaning
for(r in 1:nrow(metab)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_all_postWeaning %>% .[r,], 
                    metab_all_preWeaning %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_all_devstage_pvalue$post_v_pre <- c(metab_all_devstage_pvalue$post_v_pre, tmp)
    }
  )
}
  # reformat pvalues to dataframe
  metab_all_devstage_pvalue <- data.frame(id = rownames(metab),
          `control_v_post-weaning` = metab_all_devstage_pvalue$control_v_post,
          `control_v_pre-weaning` = metab_all_devstage_pvalue$control_v_pre,
          `post-weaning_v_pre-weaning` = metab_all_devstage_pvalue$post_v_pre, check.names = F) %>%
    pivot_longer(-id, names_to = "contrast", values_to = "pvalue")
  }



# assemble development stage difference test results
metab_all_daa_devstage <- data.frame(control_mean = metab_all_control %>% rowMeans(na.rm = T),
                                 postWeaning_mean = metab_all_postWeaning %>% rowMeans(na.rm = T),
                                 preWeaning_mean = metab_all_preWeaning %>% rowMeans(na.rm = T)) %>%
  # calculte LFC (log2 of difference in mean for each metabolite per sample group)
  rownames_to_column("id") %>% 
  mutate(category = "dev_stage", type = "all",
         `control_v_post-weaning` = log2(postWeaning_mean/control_mean),
         `control_v_pre-weaning` = log2(preWeaning_mean/control_mean),
         `post-weaning_v_pre-weaning` = log2(preWeaning_mean/postWeaning_mean)) %>%
  # pivot to long data (one row per metabolite and contrast)
  pivot_longer(`control_v_post-weaning`:`post-weaning_v_pre-weaning`,
               names_to = "contrast", values_to = "log2FoldChange") %>% 
  # add t-test pvalues
  left_join(metab_all_devstage_pvalue, by = join_by(id, contrast)) %>% 
  mutate(padj = p.adjust(pvalue, method = "fdr")) %>% 
  select(id, matches("mean"), log2FoldChange, pvalue, padj, category, type, contrast)


# --digesta samples--------------------
# split metabolite data according to AcGGM inclusion stage
metab_digesta_postWeaning <- metab_digesta %>% select(any_of(sample_meta %>% filter(dev_stage == "post-weaning") %>% pull(sample)))
metab_digesta_preWeaning <- metab_digesta %>% select(any_of(sample_meta %>% filter(dev_stage == "pre-weaning") %>% pull(sample)))

# t-test of each metabolite. if all missing values, set pvalue to NA
{metab_digesta_devstage_pvalue <- list(control_v_post = c(),
                                   control_v_pre = c(),
                                   post_v_pre = c())
## control vs. post-weaning
for(r in 1:nrow(metab_digesta)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_digesta_control %>% .[r,], 
                    metab_digesta_postWeaning %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_digesta_devstage_pvalue$control_v_post <- c(metab_digesta_devstage_pvalue$control_v_post, tmp)
    }
  )
}
## control vs. pre-weaning
for(r in 1:nrow(metab_digesta)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_digesta_control %>% .[r,], 
                    metab_digesta_preWeaning %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_digesta_devstage_pvalue$control_v_pre <- c(metab_digesta_devstage_pvalue$control_v_pre, tmp)
    }
  )
}
## post- vs. pre-weaning
for(r in 1:nrow(metab_digesta)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_digesta_postWeaning %>% .[r,], 
                    metab_digesta_preWeaning %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_digesta_devstage_pvalue$post_v_pre <- c(metab_digesta_devstage_pvalue$post_v_pre, tmp)
    }
  )
}
  # reformat pvalues to dataframe
  metab_digesta_devstage_pvalue <- data.frame(id = rownames(metab_digesta),
          `control_v_post-weaning` = metab_digesta_devstage_pvalue$control_v_post,
          `control_v_pre-weaning` = metab_digesta_devstage_pvalue$control_v_pre,
          `post-weaning_v_pre-weaning` = metab_digesta_devstage_pvalue$post_v_pre, check.names = F) %>%
    pivot_longer(-id, names_to = "contrast", values_to = "pvalue")
  }



# assemble development stage difference test results
metab_digesta_daa_devstage <- data.frame(control_mean = metab_digesta_control %>% rowMeans(na.rm = T),
                                 postWeaning_mean = metab_digesta_postWeaning %>% rowMeans(na.rm = T),
                                 preWeaning_mean = metab_digesta_preWeaning %>% rowMeans(na.rm = T)) %>%
  # calculte LFC (log2 of difference in mean for each metabolite per sample group)
  rownames_to_column("id") %>% 
  mutate(category = "dev_stage", type = "digesta",
         `control_v_post-weaning` = log2(postWeaning_mean/control_mean),
         `control_v_pre-weaning` = log2(preWeaning_mean/control_mean),
         `post-weaning_v_pre-weaning` = log2(preWeaning_mean/postWeaning_mean)) %>%
  # pivot to long data (one row per metabolite and contrast)
  pivot_longer(`control_v_post-weaning`:`post-weaning_v_pre-weaning`,
               names_to = "contrast", values_to = "log2FoldChange") %>% 
  # add t-test pvalues
  left_join(metab_digesta_devstage_pvalue, by = join_by(id, contrast)) %>% 
  mutate(padj = p.adjust(pvalue, method = "fdr")) %>% 
  select(id, matches("mean"), log2FoldChange, pvalue, padj, category, type, contrast)


# --tissue samples--------------------
# split metabolite data according to AcGGM inclusion stage
metab_tissue_postWeaning <- metab_tissue %>% select(any_of(sample_meta %>% filter(dev_stage == "post-weaning") %>% pull(sample)))
metab_tissue_preWeaning <- metab_tissue %>% select(any_of(sample_meta %>% filter(dev_stage == "pre-weaning") %>% pull(sample)))

# t-test of each metabolite. if all missing values, set pvalue to NA
{metab_tissue_devstage_pvalue <- list(control_v_post = c(),
                                   control_v_pre = c(),
                                   post_v_pre = c())
## control vs. post-weaning
for(r in 1:nrow(metab_tissue)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_tissue_control %>% .[r,], 
                    metab_tissue_postWeaning %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_tissue_devstage_pvalue$control_v_post <- c(metab_tissue_devstage_pvalue$control_v_post, tmp)
    }
  )
}
## control vs. pre-weaning
for(r in 1:nrow(metab_tissue)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_tissue_control %>% .[r,], 
                    metab_tissue_preWeaning %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_tissue_devstage_pvalue$control_v_pre <- c(metab_tissue_devstage_pvalue$control_v_pre, tmp)
    }
  )
}
## post- vs. pre-weaning
for(r in 1:nrow(metab_tissue)){
  tryCatch(
    expr = {
      tmp <- t.test(metab_tissue_postWeaning %>% .[r,], 
                    metab_tissue_preWeaning %>% .[r,], var.equal = T)$p.value
      },
    error = function(e){
      tmp <- NA
    },
    finally = {
      metab_tissue_devstage_pvalue$post_v_pre <- c(metab_tissue_devstage_pvalue$post_v_pre, tmp)
    }
  )
}
  # reformat pvalues to dataframe
  metab_tissue_devstage_pvalue <- data.frame(id = rownames(metab_tissue),
          `control_v_post-weaning` = metab_tissue_devstage_pvalue$control_v_post,
          `control_v_pre-weaning` = metab_tissue_devstage_pvalue$control_v_pre,
          `post-weaning_v_pre-weaning` = metab_tissue_devstage_pvalue$post_v_pre, check.names = F) %>%
    pivot_longer(-id, names_to = "contrast", values_to = "pvalue")
  }



# assemble development stage difference test results
metab_tissue_daa_devstage <- data.frame(control_mean = metab_tissue_control %>% rowMeans(na.rm = T),
                                 postWeaning_mean = metab_tissue_postWeaning %>% rowMeans(na.rm = T),
                                 preWeaning_mean = metab_tissue_preWeaning %>% rowMeans(na.rm = T)) %>%
  # calculte LFC (log2 of difference in mean for each metabolite per sample group)
  rownames_to_column("id") %>% 
  mutate(category = "dev_stage", type = "tissue",
         `control_v_post-weaning` = log2(postWeaning_mean/control_mean),
         `control_v_pre-weaning` = log2(preWeaning_mean/control_mean),
         `post-weaning_v_pre-weaning` = log2(preWeaning_mean/postWeaning_mean)) %>%
  # pivot to long data (one row per metabolite and contrast)
  pivot_longer(`control_v_post-weaning`:`post-weaning_v_pre-weaning`,
               names_to = "contrast", values_to = "log2FoldChange") %>% 
  # add t-test pvalues
  left_join(metab_tissue_devstage_pvalue, by = join_by(id, contrast)) %>% 
  mutate(padj = p.adjust(pvalue, method = "fdr")) %>% 
  select(id, matches("mean"), log2FoldChange, pvalue, padj, category, type, contrast)
```

```{r metaB differential abundance analysis assemble, eval = F}
# --COMBINE METAB DIFFERENTIAL ABUNDANCE TEST RESULTS-----------------
# --both sample types------------
metab_all_daa <- metab_daa_type %>% select(-matches("mean")) %>%
  rbind(metab_all_daa_diet %>% select(-matches("mean"))) %>%
  rbind(metab_all_daa_devstage %>% select(-matches("mean")))

# significant
metab_all_daa_signif <- metab_all_daa %>%
  filter(abs(log2FoldChange) > threshold_lfc,
         padj < threshold_padj) %>% 
  # facilitate significance bar plotting
  ## add annotations
  left_join(metab_annotations %>% select(id:flag), by = "id") %>% 
  ## create labels
  mutate(label = str_c(id, "\n", ifelse(is.na(name),
                                 ifelse(is.na(formula), "not annotated", formula),
                                                                         name)),
         bar_start = word(contrast, 1, sep  = "_"),
         bar_stop = word(contrast, 3, sep = "_"),
         across(bar_start:bar_stop, \(x) factor(x,
                                                levels = c("digesta", "tissue", # sample type
                                                           "control", "AcGGM", # diet group
                                                           "pre-weaning", "post-weaning"))), # devstage
         bar_label = str_c(round(log2FoldChange, 2), " ",
                           ifelse(padj < 0.001, "***", ifelse(padj < 0.01, "**", "*")))) %>% 
  ## define y coordinate just above highest observed count value
  group_by(id, category) %>% 
  rowwise() %>% 
  mutate(bar_y = metab_log2[id,] %>% max(na.rm = T),
         bar_y = ifelse(contrast == "control_v_pre-weaning",
                        bar_y * 1.15, bar_y * 1.05)) %>% 
  ungroup()


# --digesta samples------------
metab_digesta_daa <- metab_digesta_daa_diet %>% select(-matches("mean")) %>%
  rbind(metab_digesta_daa_devstage %>% select(-matches("mean")))

# significant
metab_digesta_daa_signif <- metab_digesta_daa %>%
  filter(abs(log2FoldChange) > threshold_lfc,
         padj < threshold_padj) %>% 
  # facilitate significance bar plotting
  ## add annotations
  left_join(metab_annotations %>% select(id:flag), by = "id") %>% 
  ## create labels
  mutate(label = str_c(id, "\n", ifelse(is.na(name),
                                 ifelse(is.na(formula), "not annotated", formula),
                                                                         name)),
         bar_start = word(contrast, 1, sep  = "_"),
         bar_stop = word(contrast, 3, sep = "_"),
         across(bar_start:bar_stop, \(x) factor(x,
                                                levels = c("control", "AcGGM", # diet group
                                                           "pre-weaning", "post-weaning"))), # devstage
         bar_label = str_c(round(log2FoldChange, 2), " ",
                           ifelse(padj < 0.001, "***", ifelse(padj < 0.01, "**", "*")))) %>% 
  ## define y coordinate just above highest observed count value
  group_by(id, category) %>% 
  rowwise() %>% 
  mutate(bar_y = metab_log2[id,] %>% max(na.rm = T),
         bar_y = ifelse(contrast == "control_v_pre-weaning",
                        bar_y * 1.15, bar_y * 1.05)) %>% 
  ungroup()


# --tissue samples------------
metab_tissue_daa <- metab_tissue_daa_diet %>% select(-matches("mean")) %>%
  rbind(metab_tissue_daa_devstage %>% select(-matches("mean")))

# significant
metab_tissue_daa_signif <- metab_tissue_daa %>%
  filter(abs(log2FoldChange) > threshold_lfc,
         padj < threshold_padj) %>% 
  # facilitate significance bar plotting
  ## add annotations
  left_join(metab_annotations %>% select(id:flag), by = "id") %>% 
  ## create labels
  mutate(label = str_c(id, "\n", ifelse(is.na(name),
                                 ifelse(is.na(formula), "not annotated", formula),
                                                                         name)),
         bar_start = word(contrast, 1, sep  = "_"),
         bar_stop = word(contrast, 3, sep = "_"),
         across(bar_start:bar_stop, \(x) factor(x,
                                                levels = c("control", "AcGGM", # diet group
                                                           "pre-weaning", "post-weaning"))), # devstage
         bar_label = str_c(round(log2FoldChange, 2), " ",
                           ifelse(padj < 0.001, "***", ifelse(padj < 0.01, "**", "*")))) %>% 
  ## define y coordinate just above highest observed count value
  group_by(id, category) %>% 
  rowwise() %>% 
  mutate(bar_y = metab_log2[id,] %>% max(na.rm = T),
         bar_y = ifelse(contrast == "control_v_pre-weaning",
                        bar_y * 1.15, bar_y * 1.05)) %>% 
  ungroup()


# --COMBINE-----------
# all results
metab_daa <- metab_all_daa %>% 
  rbind(metab_digesta_daa) %>% 
  rbind(metab_tissue_daa) %>% 
  # add annotations
  left_join(metab_annotations %>% select(id, name, formula, flag), by = "id") %>% 
  select(type, category, contrast, id, name, formula, flag, log2FoldChange, padj)

# significant results
metab_daa_signif <- metab_all_daa_signif %>% 
  rbind(metab_digesta_daa_signif) %>% 
  rbind(metab_tissue_daa_signif) %>% 
  select(type, category, contrast, id, name, formula, flag,
         log2FoldChange, padj, label, bar_start:bar_y)
```

```{r save metab results, eval = F, include = F}
# local
metab_log2 %>% write.csv("data/processed/omics/metaB_log2.csv")
metab_daa %>% write.csv("results/diff_abundance_expression/metaB_diff_abundance.csv")
metab_daa_signif %>% write.csv("results/diff_abundance_expression/metaB_sign_diff_abundance.csv")

# save to github
metab_log2 %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/metaB_log2.csv")
metab_daa %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/results/diff_abundance_expression/metaB_diff_abundance.csv")
metab_daa_signif %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/results/diff_abundance_expression/metaB_sign_diff_abundance.csv")

# remove intermediate objects
rm(metab_daa_type, metab_type_pvalue,
   metab_all_acggm, metab_all_control,
   metab_all_preWeaning, metab_all_postWeaning,
   metab_digesta, metab_digesta_acggm, metab_digesta_control,
   metab_digesta_postWeaning, metab_digesta_preWeaning,
   metab_tissue, metab_tissue_acggm, metab_tissue_control,
   metab_tissue_postWeaning, metab_tissue_preWeaning,
   metab_all_daa, metab_all_daa_diet, metab_all_daa_devstage, metab_all_daa_signif,
   metab_all_diet_pvalue, metab_all_devstage_pvalue,
   metab_digesta_daa, metab_digesta_daa_diet, metab_digesta_daa_devstage, metab_digesta_daa_signif,
   metab_digesta_diet_pvalue, metab_digesta_devstage_pvalue,
   metab_tissue_daa, metab_tissue_daa_diet, metab_tissue_daa_devstage, metab_tissue_daa_signif,
   metab_tissue_diet_pvalue, metab_tissue_devstage_pvalue)
```

```{r load metab results, echo = F}
# load result files
metab_log2 <- read.csv("data/processed/omics/metaB_log2.csv", row.names = 1)
metab_daa <- read.csv("results/diff_abundance_expression/metaB_diff_abundance.csv") %>% select(-X)
metab_daa_signif <- read.csv("results/diff_abundance_expression/metaB_sign_diff_abundance.csv") %>% select(-X)
```

------------------------------------------------------------------------

<br>

## Host transcriptomics {.unnumbered}

The hostT data may be used to compare the transcriptional activity in the caecal wall tissue of pigs across different `diet` groups and `dev_stage` for AcGGM inclusion start.

```{r host differential expression analysis, eval = F}
# --HOSTT DATA DESEQ OBJECTS------------------------
# DIET GROUP (control vs. AcGGM)
# create deseq object
{hostt_dds_diet <- hostt %>%
  select(any_of(sample_meta %>% pull(sample))) %>% 
  DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "hostT"),
                           design = ~diet)
# ensure correct reference level is used
hostt_dds_diet$diet <- relevel(hostt_dds_diet$diet, ref = "control")

# run analysis
hostt_dds_diet <- hostt_dds_diet %>% DESeq()}

# extract results
hostt_dea_diet <- hostt_dds_diet %>%
  results(contrast = c("diet", "AcGGM", "control")) %>% as.data.frame() %>%
  rownames_to_column("gene") %>% 
  mutate(category = "diet", contrast = "control_v_AcGGM")

# extract significant results
hostt_dea_diet_signif <- hostt_dea_diet %>%
  filter(abs(log2FoldChange) > threshold_lfc,
         # baseMean > threshold_baseMean,
         padj < threshold_padj)

# ----------------------------------
# DEVELOPMENT STAGE (control vs. post- vs. pre-weaning)
# create deseq object
{hostt_dds_devstage <- hostt %>%
  select(any_of(sample_meta %>% pull(sample))) %>% 
  DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "hostT"),
                           design = ~dev_stage)
# ensure correct reference level is used
hostt_dds_devstage$dev_stage <- relevel(hostt_dds_devstage$dev_stage, ref = "control")

# run analysis
hostt_dds_devstage <- hostt_dds_devstage %>% DESeq()}

# extract results
hostt_dea_devstage <- results(hostt_dds_devstage, contrast = c("dev_stage", "pre-weaning", "control")) %>%
  as.data.frame() %>% rownames_to_column("gene") %>% 
  mutate(category = "dev_stage", contrast = "control_v_pre-weaning") %>% 
  ## control vs. post-weaning
  rbind(results(hostt_dds_devstage, contrast = c("dev_stage", "post-weaning", "control")) %>%
  as.data.frame() %>% rownames_to_column("gene") %>% 
  mutate(category = "dev_stage", contrast = "control_v_post-weaning")) %>% 
  ## pre- vs. post-weaning
  rbind(results(hostt_dds_devstage, contrast = c("dev_stage", "pre-weaning", "post-weaning")) %>%
  as.data.frame() %>% rownames_to_column("gene") %>% 
  mutate(category = "dev_stage", contrast = "post-weaning_v_pre-weaning"))

# extract significant results
hostt_dea_devstage_signif <- hostt_dea_devstage %>% 
  filter(abs(log2FoldChange) > threshold_lfc,
         # baseMean > threshold_baseMean,
         padj < threshold_padj)


# --APPLY VST---------------------------------
hostt_vst <- hostt %>%
  DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "hostT"),
                           design = ~diet) %>%
  varianceStabilizingTransformation() %>% 
  assay() %>% as.data.frame()


# --COMBINE HOSTT DIFFERENTIAL EXPRESSION TEST RESULTS-----------------
# all results
hostt_dea <- hostt_dea_diet %>%
  rbind(hostt_dea_devstage) %>% 
  # add annotations
  left_join(host_annotations %>% select(gene, annotation = description, gene_id),
            by = "gene", relationship = "many-to-many") %>% 
  select(category, contrast, gene, gene_id, annotation, log2FoldChange, padj, baseMean)

# significant
hostt_dea_signif <- hostt_dea_diet_signif %>%
  rbind(hostt_dea_devstage_signif) %>%
  # facilitate significance bar plotting
  ## add annotations
  left_join(host_annotations, by = "gene") %>% 
  
  ## create labels
  mutate(label = str_c(gene, ifelse(is.na(description), "", str_c("\n", description))),
         bar_start = word(contrast, 1, sep  = "_"),
         bar_stop = word(contrast, 3, sep = "_"),
         across(bar_start:bar_stop, \(x) factor(x,
                                                levels = c("control", "AcGGM", # diet group
                                                           "pre-weaning", "post-weaning"))), # devstage
         bar_label = str_c(round(log2FoldChange, 2), " ",
                           ifelse(padj < 0.001, "***", ifelse(padj < 0.01, "**", "*")))) %>% 
  ## define y coordinate just above highest observed read count value
  group_by(gene, category) %>% 
  rowwise() %>% 
  mutate(bar_y = hostt_vst[gene,] %>% max(na.rm = T),
         bar_y = ifelse(contrast == "control_v_pre-weaning",
                        bar_y * 1.15, bar_y * 1.05)) %>% 
  ungroup() %>% 
  select(category, contrast, gene, gene_id, annotation = description,
         log2FoldChange, padj, baseMean, label, bar_start:bar_y)
```

```{r save hostt results, eval = F, include = F}
# local
hostt_vst %>% write.csv("data/processed/omics/hostT_vst.csv")
hostt_dea %>% write.csv("results/diff_abundance_expression/hostT_diff_expression.csv")
hostt_dea_signif %>% write.csv("results/diff_abundance_expression/hostT_sign_diff_expression.csv")

# to github
hostt_vst %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/hostT_vst.csv")
hostt_dea %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/results/diff_abundance_expression/hostT_diff_expression.csv")
hostt_dea_signif %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/results/diff_abundance_expression/hostT_sign_diff_expression.csv")

# remove intermediate objects
rm(hostt_dds_diet, hostt_dds_devstage,
   hostt_dea_diet, hostt_dea_devstage,
   hostt_dea_diet_signif, hostt_dea_devstage_signif)
```

```{r load hostt results, echo = F}
# load results
hostt_vst <- read.csv("data/processed/omics/hostT_vst.csv", row.names = 1)
hostt_dea <- read.csv("results/diff_abundance_expression/hostT_diff_expression.csv") %>% select(-X)
hostt_dea_signif <- read.csv("results/diff_abundance_expression/hostT_sign_diff_expression.csv") %>% select(-X)
```

------------------------------------------------------------------------

<br>

# Single-omic investigations

## Differential abundance/expression results {.tabset}

The table below summarises the outcomes of the differential abundance and expression analyses across different sample groups and omic layers.

```{r daa dea summary table}
# gather all diff ab results
daa_dea_summary <- metag_daa %>% mutate(layer = "metaG") %>%
          select(layer, feature = MAG, category, contrast, log2FoldChange, padj) %>% 
  rbind(metat_dea %>% mutate(layer = "metaT") %>% 
          select(layer, feature = gene, category, contrast, log2FoldChange, padj)) %>% 
  rbind(metab_daa %>% filter(type == "all", category == "type") %>%
          mutate(layer = "metaB") %>%
          select(layer, feature = id, category, contrast, log2FoldChange, padj)) %>% 
  rbind(metab_daa %>% filter(grepl("digesta", type)) %>%
          mutate(layer = "metaB_digesta") %>%
          select(layer, feature = id, category, contrast, log2FoldChange, padj)) %>% 
  rbind(metab_daa %>% filter(grepl("tissue", type)) %>%
          mutate(layer = "metaB_tissue") %>%
          select(layer, feature = id, category, contrast, log2FoldChange, padj)) %>% 
  rbind(hostt_dea %>% mutate(layer = "hostT") %>% 
          select(layer, feature = gene, category, contrast, log2FoldChange, padj)) %>% 
  mutate(layer = factor(layer, levels = c("metaG", "metaT", "metaB",
                                          "metaB_digesta", "metaB_tissue", "hostT")),
         category = factor(category, levels = c("type", "diet", "dev_stage")),
         contrast = factor(contrast, levels = c("digesta_v_tissue",
                                                "control_v_AcGGM",
                                                "control_v_post-weaning",
                                                "control_v_pre-weaning",
                                                "post-weaning_v_pre-weaning")))
# extract significant results
daa_dea_signif_summary <- daa_dea_summary %>%
  filter(abs(log2FoldChange) > 1 & padj < 0.05)

# create summary
daa_dea_signif_summary %>% 
  group_by(layer, category, contrast, .drop = F) %>%
  summarise(n_up = sum(log2FoldChange > 0),
            n_down = sum(log2FoldChange < 0)) %>%
  ungroup() %>%
  # discard irrelevant contrasts
  filter(!(category == "type" & !grepl("digesta", contrast)),
         !(grepl("digesta", contrast) & category != "type"),
         !(category == "diet" & contrast != "control_v_AcGGM"),
         !(category == "dev_stage" & contrast == "control_v_AcGGM"),
         !(layer != "metaB" & category == "type")) %>% 
  # join columns reporting numbers
  mutate(value = str_c("↑", n_up, " ↓", n_down)) %>% 
  select(-n_up, -n_down) %>% 
  pivot_wider(names_from = "layer", values_from = "value") %>% 
  pretty_table(text = "Summary of differential abundance and expression analyses. For each omic layer and experimental contrast, the cells report the number of features with significant increases (↑) and decreases (↓) in the second named contrast group compared to the first. The \"metaB\" column combines metabolomic data generated from digesta and tissue samples.")
```

In the table above, "↑1289 ↓1268" for the sample type contrast `digesta_v_tissue` in the overall metabolomics layer for instance means that the observed amount of 1289 compounds were significantly higher in the tissue samples, and 1268 others were found significantly more prevalent in the digesta samples.

Both metaG and metaT omic layers report different microbial abundance and gene expression patterns between different experimental groups, in which a higher degree of AcGGM supplementation tend to lead to a narrower community composition and activity (i.e., more down- than up-regulated features). The metaB omic layers display most different features when comparing sample types, and very few metabolites vary according to the animals' AcGGM supplementation diet. There are some differences observed in host gene expression profiles across diet groups; these patterns are however less consistent than the observations in the metaG and metaT layers for the same contrasts.

Grouped by omic layer, we can see that while there are more features that display differential expression in metaT than in any other omic layer. However, accounting for the size of each layer reveal that a much bigger proportion of metabolites and MAGs are differentially abundant across sample type and diet group, respectively, than microbial genes.

```{r diff ab exp ratio among all features per layer, echo = F}
# summary table counting unique features with at least one diff ab/exp result, and percentwise diff ab/exp per layer
data.frame(layer = c("metaG",
                     "metaT",
                     "metaB (sample)",
                     "metaB digesta (diet)",
                     "metaB tissue (diet)",
                     "hostT"),
           features = c(nrow(metag),
                        nrow(metat),
                        nrow(metab),
                        nrow(metab %>% select(ends_with("I"))),
                        nrow(metab %>% select(ends_with("K"))),
                        nrow(hostt)),
           unique_diff_ab = c(nrow(metag_daa_signif %>% distinct(MAG)),
                             nrow(metat_dea_signif %>% distinct(gene)),
                             nrow(metab_daa_signif %>%
                                    filter(category == "type") %>% distinct(id)),
                             nrow(metab_daa_signif %>% filter(type == "digesta") %>% 
                                    distinct(id)),
                             nrow(metab_daa_signif %>% filter(type == "tissue") %>%
                                    distinct(id)),
                             nrow(hostt_dea_signif %>% distinct(gene)))) %>% 
  mutate(percent_diff_ab = round(unique_diff_ab/features*100, 2)) %>% 
  rbind(data.frame(layer = "TOTAL",
                   features = sum(nrow(metag), nrow(metat), nrow(metab), nrow(hostt)),
                   unique_diff_ab = sum(.$unique_diff_ab)) %>% 
          mutate(percent_diff_ab = round(unique_diff_ab/features*100, 2))) %>% 
  pretty_table(text = "Counts of total and differentially abundant/expressed features across omic layers.")
```

<br>

All features found to be different across sample groups are displayed in tables in the subsections below, and data of features from the metaG, metaB, and hostT layers have been visualised In **Suppl. 3**.

<br>

### Metagenomics {.unnumbered}

```{r daa metag, echo = F}
metag_daa_signif %>% 
  select(category, contrast, MAG, taxonomy, log2FoldChange, padj, baseMean) %>%
  pretty_table(text = "Microbial populations with signficant differential abundace between sample subsets as defined by columns \"category\" and \"contrast\".")
```

------------------------------------------------------------------------

<br>

### Metatranscriptomics {.unnumbered}

```{r echo = F}
metat_dea_signif %>% 
  select(category, contrast, gene, taxonomy, annotation, log2FoldChange, padj, baseMean) %>%
  pretty_table(text = "Microbial genes with signficant differential expression between sample subsets as defined by columns \"category\" and \"contrast\".")
```

------------------------------------------------------------------------

<br>

### Metabolomics {.unnumbered}

```{r echo = F}
metab_daa_signif %>% 
  select(type, category, contrast, id, name, formula, flag, log2FoldChange, padj) %>% 
  pretty_table(text = "Metabolites with signficant differential abundance between sample subsets as defined by columns \"type\", \"category\" and \"contrast\".")
```

------------------------------------------------------------------------

<br>

### Host transcriptomics {.unnumbered}

```{r echo = F}
hostt_dea_signif %>% 
  select(category, contrast, gene, annotation, log2FoldChange, padj, baseMean) %>%
  arrange(gene, log2FoldChange) %>% 
  
  pretty_table(text = "Host genes with signficant differential expression between sample subsets as defined by columns \"category\" and \"contrast\".")
```

------------------------------------------------------------------------

<br>

## Interpretations

### Maturation

First, we evaluated the relative abundances of key genera in the porcine gut.

```{r fig.width=15, fig.height=8, out.width="70%"}
# --MICROBIAL COMPOSITION ACORSS DIET GROUPS---------------
# taxonomic level to group by (1: domain, 7: species)
level <- 4

# pivot data to facilitate plotting
metag_vst %>% 
  rownames_to_column("MAG") %>% 
  pivot_longer(-MAG, names_to = "sample", values_to = "vst") %>% 
  # vst can be negative due to log transformation - hence replace these with 0s
  # to not take away from total across taxa
  mutate(vst = ifelse(vst<0, 0, vst)) %>% 
  # add sample and taxonomy metadata
  left_join(sample_meta %>% select(sample, diet, dev_stage, type), by = "sample") %>% 
  left_join(taxonomy %>% select(MAG, domain:species), by = "MAG") %>% 
  
  # plot
  ggplot() +
  # stacked bars
  geom_col(aes(vst, dev_stage, fill = get(tax_levels[level])),
           position = position_fill(reverse = T)) +
  scale_fill_manual(values = annot_colours[[tax_levels[level]]]) +
  guides(fill = guide_legend(title = tax_levels[level])) +
  labs(title = "Microbial composition across diet groups") +
  
  # scales
  scale_y_discrete(limit = rev, expand = c(0.0, 0)) +
  scale_x_continuous(expand = c(0.01, 0)) +
  
  # diet groups in facets
  facet_nested(rows = vars(diet, dev_stage),
               scales = "free", switch = "y", space = "free") +
  
  # appearance
  theme(plot.title = element_text(size = 20, hjust = 0.5),
        axis.title = element_blank(),
        axis.text = element_text(size = 12),
        axis.text.y = element_blank(),
        strip.text = element_text(size = 15),
        axis.ticks.y = element_blank(),
        
        legend.position = "top",
        legend.title.position = "top",
        legend.title = element_text(size = 15, hjust = 0.5),
        legend.text = element_text(size = 14, vjust = 0.5),
        legend.spacing.x = unit(50, "pt"),
        legend.key.spacing.x = unit(15, "pt"),
        
        panel.background = element_rect(fill = "white"),
        plot.background = element_rect(fill = "white"),
        strip.background = element_rect(fill = "grey87"),
        panel.grid = element_blank())
```

<br>

The composition appears very much alike at first glance. Some specific genera of interest:

```{r composition percentage calculation}
#--RELATIVE ABUNDANCES OF GENERA----------------------
metag_vst %>% 
  rownames_to_column("MAG") %>% 
  pivot_longer(-MAG, names_to = "sample", values_to = "vst") %>% 
  # vst can be negative due to log transformation - hence replace these with 0s
  # to not take away from total across taxa
  mutate(vst = ifelse(vst<0, 0, vst)) %>% 
  # add sample and taxonomy metadata
  left_join(sample_meta %>% select(sample, diet, dev_stage, type), by = "sample") %>% 
  left_join(taxonomy %>% select(MAG, genus), by = "MAG") %>% 
  
  # calculate relative abundances per genus
  group_by(genus) %>% 
  mutate(total_genus = sum(vst, na.rm = T)) %>% 
  ungroup() %>% 
  # reformat and pivot
  mutate(relative_abundance = round(total_genus/sum(vst, na.rm = T)*100, 2)) %>% 
  select(genus, relative_abundance) %>%
  
  # order and display
  distinct() %>% arrange(desc(relative_abundance)) %>% 
  pretty_table(text = "Relative abundances of genera in the porcine caecal samples, given in percent.")
```

From this table, we see that taxa associated with the infant gut - including *Bacteroides*, *Clostridium*, *Escherichia* and *Lactobacillus* - have low relative abundance, while taxa more common in the mature porcine gut - such as *Prevotella*, *Alloprevotella*, *Agathobacter*, *Faecalibacterium*, *Blautia*, and *Roseburia* - are more prevalent [[@chen2017; @luo2022; @tang2025]].

These relative abundances do however not inform on potential differences between the groups introduced to AcGGM `post-weaning`, `pre-weaning`, or not at all (`control`). We investigate these differences through the differential abundance analysis performed in the previous section.

<br>

### Selectively promoted bacterial taxa

Through early introduction of AcGGM in the porcine diet, select bacterial taxa that can degrade these fibres may gain a competetive advantage in the colonisation of the infant porcine gut. We therefore compared the observed abundances of microbes in animals in the pre-weaning AcGGM group with the others:

```{r}
#--ACGGM EARLY ADAPTATION---------------------
# all significant differential abundance test results
metag_daa_signif %>% 
  filter(category == "dev_stage",
         log2FoldChange > 0) %>% 
  select(contrast, MAG, lowest, LFC = log2FoldChange) %>%
  distinct() %>% 
  arrange(MAG, contrast) %>% 
  pretty_table()
```

<br>

In this table we can infer that the pre-weaning AcGGM introduction led to higher abundances of *Bacteroides ovatus*, *Basfia porcinus*, and *Ruminiclostridium sp.* (LFC\>6), *Lactobacillus johnsonii* (LFC\>5), *Butyribacter sp.* and *Alloprevotella sp.* (LFC\>4), *Prevotella pectinovora* (LFC\>3), and *Duodenibacillus sp.* (LFC\>2). Some of these are have been suggested as contributors to host health through functions like carbhohydrate degradation and short-chain fatty acid (SCFA) production [[@chen2017; @tang2025; @luo2022; @la_rosa_human_2019; @larosa2019; @gibson2017; @michalak_microbiota-directed_2020]], indicating that the AcGGM administration successfully modulated the gut microbiome in favour of commensal taxa.

<br>

### Concordance between metaG and metaT

Comparing the direction of differential abundance of MAGs with their genes reveals that the metaG and metaT layers align very well. In other words, whenever a MAG was found more abundant, its genes were also more expressed.

```{r}
#--METAG METAT ALIGNMENT-------------------------
# percentage of genes up- or down-regulated per MAG
metat_dea %>% select(MAG, gene, lowest, contrast) %>% 
  left_join(metat_dea_signif %>% select(gene, contrast, log2FoldChange, padj),
            by = c("gene", "contrast")) %>% 
  # count up- and down-regulated genes per MAG and contrast
  mutate(dea_direction = ifelse(is.na(log2FoldChange), "ns",
                          ifelse(log2FoldChange > 0, "up", "down"))) %>% 
  summarise(n_dea = n(), .by = c("lowest", "MAG", "contrast", "dea_direction")) %>% 
  # calculate percent of genes diff expr
  pivot_wider(names_from = "dea_direction", values_from = c("n_dea")) %>% 
  rowwise() %>%
  mutate(total = sum(ns, up, down, na.rm = T),
         across(up:down, \(x) replace_na(x, 0)),
         perc_dea_down = round(down/total*100, 2),
         perc_dea_up = round(up/total*100, 2)) %>% ungroup() %>% 
  # reformat
  arrange(desc(ifelse(is.na(perc_dea_up), perc_dea_down, perc_dea_up))) %>% 
  # add metaG diff ab result
  left_join(metag_daa %>%
              mutate(daa = str_c(round(log2FoldChange, 2),
                           ifelse(abs(log2FoldChange) > 1 & !is.na(padj) & padj < 0.05,
                                  " *", ""))) %>%
              select(MAG, contrast, daa), by = c("MAG", "contrast")) %>% 
  select(MAG, lowest, contrast, daa, perc_dea_up, perc_dea_down) %>% 
  pretty_table(text = "Percent differentially expressed genes (dea) in each direction per MAG and experimental contrast, compared to direction of change from differential abundance analyses (daa).")
```

<br>

We can for instance see that for *Alloprevotella sp004552865* in the fist row, this MAG was more abundant in animals introduced to AcGGM already in their liquid pre-weaning diet (LFC 4.59, FDR p-value \< 0.05). Almost half of the genes mapped to this MAG were determined to be differentially expressed, and all were more active in the pre-weaning AcGGM-fed animals.

There were just two genes that were observed to change in a different direction than the abundance of the MAG:

```{r deviations from metag metat concordance}
#--DEVIATIONS METAG METAG ALIGNMENT--------------------
# diff expr genes
metat_dea %>%
  select(category, contrast, MAG, gene,
         dea_lfc = log2FoldChange, dea_padj = padj, lowest, annotation) %>% 
  # add diff abundance results
  left_join(metag_daa %>%
              select(MAG, contrast, daa_lfc = log2FoldChange, daa_padj = padj),
            by = c("MAG", "contrast")) %>%
  # get direction of change
  mutate(daa = replace_na(abs(daa_lfc) > 1 & daa_padj < 0.05, F),
         dea = replace_na(abs(dea_lfc) > 1 & dea_padj < 0.05, F)) %>%
  mutate(daa_direction = ifelse(daa_lfc > 0, "up", "down"),
         dea_direction = ifelse(dea_lfc > 0, "up", "down")) %>% 
  # show just those that don't agree
  filter(daa, dea, daa_direction != dea_direction) %>% 
  pretty_table(text = "Deviations from the trend that all differentially expressed genes followed the direction of change of the respective MAG's abundance.")
```

<br>

Hence in general, we infer that MAGs found to be more abundant were also more active when AcGGM was provided to piglets at an early developmental stage. The same was true for taxa named in the previous section which appeared to be promoted by the early AcGGM introduction. Hence the microbiota-directed fibre (MDF) appears to directly have influenced both the composition *and* functional activity of the caecal microbiota.

<br>

## Limitations to single-omic interpretations

Investigating the omic datasets independently helps us discover the potential implications of AcGGM administration on the host' caecal gene expression, the resident microbiota, and its metabolomic composition. For instance, we have seen in the above sections that 1) the microbial communities in the porcine caecum samples were dominated by taxa associated with a mature gut microbiomes, and 2) that the AcGGM appeared to have influenced the microbiome with respect to both microbial community composition (metaG) and its functional activity (metaT), as well as host gene expression (hostT). The metabolome (metaB) differed most with respect to sample type (digesta vs. tissue), and very few metabolites varied between the diet groups.

Thus we have identified some changes that occured within the study system, but we are no closer to learn how the gut microbiome and the host interact in response to the dietary intervention. We could spend hours digging into the biology behind the differentially abundant and expressed features and try to connect the omic layers that way, but this is unlikely to yield a comprehensive understanding of the system. The porcine holobiont harbours complex functionality due to interactions across the host-microbiome barrier, and our single-omic approaches are isolated analyses that by definition cannot capture the intricacies connecting the different types of molecular features.

Thus in order to elucidate the effect of AcGGM administration – and its introduction at different stages in the porcine development – we employ a *holo-omic* analysis approach. Conceptually, this means that we use omic data from both sides of the holobiont in the same analysis. This integration enables us to draw connections between what happens to the host and to its resident microbiome in response to some experimental variable – in this case, the AcGGM dietary supplement.

<br>

# Holo-omic approach

Several methods have been developed for multi-omic analyses (e.g. see the GitHub repo [awesome-multi-omics](https://github.com/mikelove/awesome-multi-omics){target="_blank"}). There is however no widely agreed-upon standard methodology for holo-omic analyses, but several possible approaches to such an integrated analysis exist [[@kobel2024]]. We will implement one tool called FlashWeave [[@tackmann2019]], which allows us to input multiple omic layers and predict within- and cross-omic interactions through co-occurrence.

However, our dataset contains `r nrow(metag)+nrow(metat)+nrow(metab)+nrow(metab)+nrow(hostt)` features, and calculating co-occurrence between all those would not only take a long time, but also likely yield a complex hairball of a network that would be hard to interpret. We could simplify the network by reducing the feature count, for instance by only including features we've identified as differentially abundant/expressed in our single-omic analyses. However, this could introduce bias in the integration approach, and we have no way of knowing whether these features are the (only) ones that participate in cross-omic interactions, or if they are the most relevant.

To limit our feature space into a smaller one that include features relevant for cross-omic (including host-microbiome) interactions, we use multiset correlation and factor analysis (MCFA) (ver. 1.0.2) [[@brown2023]]. The method is run by by first reading in the input omic data. They must cover the same samples (rows) and different features (columns). The data is then modelled in two rounds. First, a shared space seeking to capture coordinated patterns across all input layers is fit. Then, private models are individually fit to each omic layer by using the residual from the shared space modelling process (**Fig. 1D**). In the resulting model of the observed data, each omic feature is assigned a weight for each model space. We interpret the shared weights as indicators of importance for the shared space, which seeks to capture cross-omic data patterns. By extracting all features with a shared space weighting beyond some set threshold, we can effectively select the omic features implied to be the most relevant for coordinated patterns in the observed dataset. These would be the features we then input into the software for predicting interactions.

## Multiset correlation and factor analysis

### Setup and run {.tabset}

Selecting samples from animals covered by all omic layers, limiting metabolomics to curated features, and transposing the omic tables:

```{r mcfa file prep}
# --INPUT DATA FOR MCFA------------------------
# find common samples
{mcfa_samples <- list(# metaG (digesta)
                     metag_digesta = c(metag %>% colnames() %>%
                                         .[grepl("[0-9]F", .)] %>% str_remove(., "F")),
                     # metaT (digesta)
                     metat_digesta = c(metat %>% colnames() %>% str_remove(., "F")),
                     # metaB: separate digesta (~microbial) and tissue (~host) samples
                     metab_digesta = c(metab %>% colnames() %>%
                                         .[grepl("[0-9]I", .)] %>% str_remove(., "I")),
                     metab_tissue = c(metab %>% colnames() %>% 
                                        .[grepl("[0-9]K", .)] %>% str_remove(., "K")),
                     # hostT (tissue)
                     hostt_tissue = c(hostt %>% colnames() %>% str_remove(., "H")))
mcfa_samples$common <- c(mcfa_samples$metag_digesta %>% 
                           intersect(mcfa_samples$metat_digesta) %>%
                           intersect(mcfa_samples$metab_digesta) %>%
                           intersect(mcfa_samples$metab_tissue) %>% 
                           intersect(mcfa_samples$hostt_tissue))}

# subset standardised omics data to common samples, simplify names, replace NA with 0
mcfa_metag <- metag_vst %>% select(any_of(str_c(mcfa_samples$common, "F"))) %>%
  rename_with(\(x) substr(x, 1, 4)) %>%
  t() %>% as.data.frame()
mcfa_metat <- metat_vst %>% select(any_of(str_c(mcfa_samples$common, "F"))) %>%
  rename_with(\(x) substr(x, 1, 4)) %>% 
  t() %>% as.data.frame()
mcfa_metab_tissue <- metab_log2 %>%
  select(any_of(str_c(mcfa_samples$common, "K"))) %>%
  rename_with(\(x) substr(x, 1, 4)) %>% 
  mutate(across(everything(), \(x) replace_na(x, 0))) %>% 
  t() %>% as.data.frame() 
mcfa_metab_digesta <- metab_log2 %>%
  select(any_of(str_c(mcfa_samples$common, "I"))) %>%
  rename_with(\(x) substr(x, 1, 4)) %>% 
  mutate(across(everything(), \(x) replace_na(x, 0))) %>% 
  t() %>% as.data.frame()
mcfa_hostt <- hostt_vst %>% select(any_of(str_c(mcfa_samples$common, "H"))) %>%
  rename_with(\(x) substr(x, 1, 4)) %>% 
  t() %>% as.data.frame()

# select relevant metadata
mcfa_sample_meta <- sample_meta %>% 
  mutate(sample = substr(sample, 1, 4)) %>% 
  select(sample, diet, dev_stage) %>% distinct()
```

```{r save mcfa input files, eval = F, include = F}
# normalised counts
mcfa_metag %>% write.csv("data/processed/omics/mcfa_metaG.csv")
mcfa_metat %>% write.csv("data/processed/omics/mcfa_metaT.csv")
mcfa_metab_tissue %>% write.csv("data/processed/omics/mcfa_metaB_tissue.csv")
mcfa_metab_digesta %>% write.csv("data/processed/omics/mcfa_metaB_digesta.csv")
mcfa_hostt %>% write.csv("data/processed/omics/mcfa_hostT.csv")
```

To run MCFA, a conda environment with Python (ver. 3.12.9), pandas, and the MCFA package is set up. This can be done either directly in R through the package `reticulate` (ver. 1.41.0), or by running a `.py` script in the terminal. Both approaches are documented:

#### Reticulate {.unnumbered}

Setting up a conda environment and loading the necessary libraries:

```{r conda env and setup, message = T, eval = F}
# --MCFA SETUP--------------------
# create conda environment with mcfa, or activate existing
if(condaenv_exists("mcfa")){
  use_condaenv("mcfa", required = T)
  message("Existing conda environment \"mcfa\" activated")
  } else {
    conda_create(envname = "/Users/jennymerkesvik/opt/anaconda3/envs/mcfa",  packages = c("pandas"), python_version = "3.12.9")
    use_condaenv("mcfa", required = T)
    py_install("multicor_fa", pip = T)
    message("Created and activated conda environment \"mcfa\"")
  }

# importing packages and functions
py_run_string("import pandas as pd")
py_run_string("from multicor_fa import mcfa_model")
```

Running MCFA through Python directly in RStudio:

```{python run mcfa, eval = F}
# --RUN MCFA WITH PYTHON-------------------
# define input data
data = {"metaG": pd.read_csv("data/processed/omics/mcfa_metaG.csv", index_col = 0),\
        "metaT": pd.read_csv("data/processed/omics/mcfa_metaT.csv", index_col = 0),\
        "metaB_digesta": pd.read_csv("data/processed/omics/mcfa_metaB_digesta.csv", index_col = 0),\
        "metaB_tissue": pd.read_csv("data/processed/omics/mcfa_metaB_tissue.csv", index_col = 0),\
        "hostT": pd.read_csv("data/processed/omics/mcfa_hostT.csv", index_col = 0)}

# ----------------------------------------
# create model
## scale and center: standardisation
## d: shared dimensionality
mcfa = mcfa_model.fit(data, scale = True, center = True, d = 1)

# ----------------------------------------
# save results
## shared space coordinates (samples x d), residual, and variance explained
## Z: shared components (F_s)
mcfa.Z.to_csv("results/feature_selection/Fs.csv")
mcfa.rho.to_csv("results/feature_selection/Fs_residual.csv")
mcfa.var_exp_Z.to_csv("results/feature_selection/Fs_varexpl.csv")

# for each omic layer i...
for i in mcfa.X:
  # shared space feature loadings (W_s)
  mcfa.W[i].to_csv("results/feature_selection/Ws_"+i+".csv")
  
  # private space: coordinates (F_p), feature loadings (W_p), residuals, and var. explained 
  mcfa.X[i].to_csv("results/feature_selection/Fp_"+i+".csv")
  mcfa.L[i].to_csv("results/feature_selection/Wp_"+i+".csv")
  mcfa.Phi[i].to_csv("results/feature_selection/Fp_residual_"+i+".csv")
  mcfa.var_exp_X[i].to_csv("results/feature_selection/Fp_varexpl_"+i+".csv")
```

------------------------------------------------------------------------

<br>

#### Terminal {.unnumbered}

In terminal, create a conda environment with the required packages:

```{r conda env terminal, eval = F}
# create conda environment and install mcfa
conda create -n mcfa python==3.12.9 pandas
conda activate mcfa
pip install multicor_fa
```

Then run a Python script with the MCFA analysis:

```{r run mcfa script, eval = F}
# run script using the created mcfa environment
conda run -n mcfa python run_mcfa.py
```

... where the `run_mcfa.py` script in the same directory contains the following:

```{r run_mcfa.py, eval = F}
import pandas as pd
from multicor_fa import mcfa_model

# ----------------------------------------
# define input data
data = {"metaG": pd.read_csv("data/processed/omics/mcfa_metaG.csv", index_col = 0),\
        "metaT": pd.read_csv("data/processed/omics/mcfa_metaT.csv", index_col = 0),\
        "metaB_digesta": pd.read_csv("data/processed/omics/mcfa_metaB_digesta.csv", index_col = 0),\
        "metaB_tissue": pd.read_csv("data/processed/omics/mcfa_metaB_tissue.csv", index_col = 0),\
        "hostT": pd.read_csv("data/processed/omics/mcfa_hostT.csv", index_col = 0)}


# ----------------------------------------
# create model
## scale and center: standardisation
## d: shared dimensionality
mcfa = mcfa_model.fit(data, scale = True, center = True, d = 1)

# ----------------------------------------
# save results
## shared space coordinates (samples x d), residual, and variance explained
## Z: shared components (F_s)
mcfa.Z.to_csv("results/feature_selection/Fs.csv")
mcfa.rho.to_csv("results/feature_selection/Fs_residual.csv")
mcfa.var_exp_Z.to_csv("results/feature_selection/Fs_varexpl.csv")

# for each omic layer i...
for i in mcfa.X:
  # shared space feature loadings (W_s)
  mcfa.W[i].to_csv("results/feature_selection/Ws_"+i+".csv")
  
  # private space: coordinates (F_p), feature loadings (W_p), residuals, and var. explained 
  mcfa.X[i].to_csv("results/feature_selection/Fp_"+i+".csv")
  mcfa.L[i].to_csv("results/feature_selection/Wp_"+i+".csv")
  mcfa.Phi[i].to_csv("results/feature_selection/Fp_residual_"+i+".csv")
  mcfa.var_exp_X[i].to_csv("results/feature_selection/Fp_varexpl_"+i+".csv")
```

------------------------------------------------------------------------

<br>

### The model {.tabset}

The files for the final model is available in the `results/mcfa` directory on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}. The files are read into the R environment and each component is displayed in the below tabs. Additionally, the tool outputs residuals for each model component, and variance explained by each omic layer. These were used to evaluate model performance and fit with experimental variables (**Fig. 2A-B**).

The MCFA model comprises two parts: one shared by all omic layers, and one private to each layer:

-   Shared space

    -   Shared component (F~S~): one column per inferred dimension, and a row per sample (`r nrow(mcfa_metag)`)

    -   Shared component weights (W~S~): one weight per shared component and feature, per omic layer (metaG; `r ncol(mcfa_metag)` MAGs, metaT; `r ncol(mcfa_metat)` genes, metaB digesta (microbe-associated) and tissue (host-associated); `r ncol(mcfa_metab_digesta)` metabolites each, hostT; `r ncol(mcfa_hostt)` host genes)

    -   Residual of each shared component, i.e. what remains to be modelled by private spaces

    -   Variance explained by each omic layer for each shared component

-   Private spaces

    -   Private components (F~P~): m components by `r nrow(mcfa_metag)` samples

    -   Private component weights (W~P~): one weight per private component and feature

    -   Residual of each private component per sample for each layer

    -   Variance explained by each private component per sample for each layer

```{r mcfa model components}
# --MCFA MODEL COMPONENTS--------------------------
# shared space
mcfa_Fs <- read.csv(file.path("results/feature_selection", "Fs.csv"), row.names = 1) %>% 
  rename_with(\(x) str_replace(x, "Z", "Fs"))

# omic-specific weights to shared space
mcfa_Ws <- list.files("results/feature_selection", pattern = "Ws", full.names = T) %>%
  lapply(\(x) read.csv(x, row.names = 1)) %>% 
  lapply(\(x) rename_with(x, \(y) str_replace(y, "Z", "Ws")))
names(mcfa_Ws) <- list.files("results/feature_selection", pattern = "Ws") %>%
  lapply(\(x) word(x, 2, 3, sep = "[_.]")) %>% 
  lapply(\(x) str_remove(x, ".csv"))

# private spaces
mcfa_Fp <- list.files("results/feature_selection", pattern = "^Fp_[mh][eo][ts][at].*csv", full.names = T) %>% 
  lapply(\(x) read.csv(x, row.names = 1)) %>% 
  lapply(\(x) rename_with(x, \(y) str_replace(y, "X", "Fp")))
names(mcfa_Fp) <- list.files("results/feature_selection", pattern = "^Fp_[mh][eo][ts][at].*csv") %>%
  lapply(\(x) word(x, 2, 3, sep = "[_.]")) %>% 
  lapply(\(x) str_remove(x, ".csv"))

# weights to private spaces
mcfa_Wp <- list.files("results/feature_selection", pattern = "Wp", full.names = T) %>%
  lapply(\(x) read.csv(x, row.names = 1)) %>% 
  lapply(\(x) rename_with(x, \(y) str_replace(y, "X", "Wp")))
names(mcfa_Wp) <- list.files("results/feature_selection", pattern = "Wp") %>%
  lapply(\(x) word(x, 2, 3, sep = "[_.]")) %>% 
  lapply(\(x) str_remove(x, ".csv"))


# --RESIDUALS and VARIANCE EXPLAINED---------------
# shared component
mcfa_residual_Fs <- read.csv(file.path("results/feature_selection", "Fs_residual.csv"), row.names = 1) %>%
  rename_with(\(x) str_replace(x, "X", "Fs"))
mcfa_varexpl_Fs <- read.csv(file.path("results/feature_selection", "Fs_varexpl.csv"), row.names = 1)

# private components
mcfa_residual_Fp <- list.files("results/feature_selection", pattern = "Fp_residual", full.names = T) %>% 
  lapply(\(x) read.csv(x, row.names = 1)) %>% 
  lapply(\(x) rename_with(x, \(y) str_replace(y, "X", "Fp")))
names(mcfa_residual_Fp) <- list.files("results/feature_selection", pattern = "Fp_residual") %>%
  lapply(\(x) word(x, 3, 4, sep = "[_.]")) %>% 
  lapply(\(x) str_remove(x, ".csv"))

mcfa_varexpl_Fp <- list.files("results/feature_selection", pattern = "Fp_varexpl", full.names = T) %>%
  lapply(\(x) read.csv(x, row.names = 1)) %>% 
  lapply(\(x) rename_with(x, \(y) str_replace(y, "X", "Fp")))
names(mcfa_varexpl_Fp) <- list.files("results/feature_selection", pattern = "Fp_varexpl") %>%
  lapply(\(x) word(x, 3, 4, sep = "[_.]")) %>% 
  lapply(\(x) str_remove(x, ".csv"))
```

#### Shared space {.unnumbered .tabset}

##### Shared components (F~S~) {.unnumbered}

```{r echo = F}
mcfa_Fs %>% pretty_table()
```

------------------------------------------------------------------------

<br>

##### Omic-specific loading of shared components (W~S~) {.unnumbered .tabset}

###### Metagenomic {.unnumbered}

```{r echo = F}
mcfa_Ws$metaG %>% pretty_table()
```

------------------------------------------------------------------------

<br>

###### Metatranscriptomic {.unnumbered}

```{r echo = F}
mcfa_Ws$metaT %>% 
  head(1000) %>%
  pretty_table(text = str_c("1000 first rows of total ", nrow(mcfa_Ws$metaT)))
```

------------------------------------------------------------------------

<br>

###### Metabolomic (microbiota-associated/digesta) {.unnumbered}

```{r echo = F}
mcfa_Ws$metaB_digesta %>%
  head(1000) %>%
  pretty_table(text = str_c("1000 first rows of total ", nrow(mcfa_Ws$metaB_digesta)))
```

------------------------------------------------------------------------

<br>

###### Metabolomic (host-associated/tissue) {.unnumbered}

```{r echo = F}
mcfa_Ws$metaB_tissue %>%
  head(1000) %>%
  pretty_table(text = str_c("1000 first rows of total ", nrow(mcfa_Ws$metaB_tissue)))
```

------------------------------------------------------------------------

<br>

###### Host transcriptomic {.unnumbered}

```{r echo = F}
mcfa_Ws$hostT %>%
  head(1000) %>%
  pretty_table(text = str_c("1000 first rows of total ", nrow(mcfa_Ws$hostT)))
```

------------------------------------------------------------------------

<br>

#### Private spaces {.unnumbered .tabset}

##### Private components (F~P~) {.unnumbered .tabset}

###### Metagenomic {.unnumbered}

```{r echo = F}
mcfa_Fp$metaG %>% pretty_table()
```

------------------------------------------------------------------------

<br>

###### Metatranscriptomic {.unnumbered}

```{r echo = F}
mcfa_Fp$metaT %>% pretty_table()
```

------------------------------------------------------------------------

<br>

###### Metabolomic (microbiota-associated/digesta) {.unnumbered}

```{r echo = F}
mcfa_Fp$metaB_digesta %>% pretty_table()
```

------------------------------------------------------------------------

<br>

###### Metabolomic (host-associated/tissue) {.unnumbered}

```{r echo = F}
mcfa_Fp$metaB_tissue %>% pretty_table()
```

------------------------------------------------------------------------

<br>

###### Host transcriptomic {.unnumbered}

```{r echo = F}
mcfa_Fp$hostT %>% pretty_table()
```

------------------------------------------------------------------------

<br>

##### Omic-specific loadings of private components (W~P~) {.unnumbered .tabset}

###### Metagenomic {.unnumbered}

```{r echo = F}
mcfa_Wp$metaG %>% pretty_table()
```

------------------------------------------------------------------------

<br>

###### Metatranscriptomic {.unnumbered}

```{r echo = F}
mcfa_Wp$metaT %>%
  head(1000) %>%
  pretty_table(text = str_c("1000 first rows of total ", nrow(mcfa_Wp$metaT)))
```

------------------------------------------------------------------------

<br>

###### Metabolomic (microbiota-associated/digesta) {.unnumbered}

```{r echo = F}
mcfa_Wp$metaB_digesta %>%
  head(1000) %>%
  pretty_table(text = str_c("1000 first rows of total ", nrow(mcfa_Wp$metaB_digesta)))
```

------------------------------------------------------------------------

<br>

###### Metabolomics (host-associated/tissue) {.unnumbered}

```{r echo = F}
mcfa_Wp$metaB_tissue %>%
  head(1000) %>%
  pretty_table(text = str_c("1000 first rows of total ", nrow(mcfa_Wp$metaB_tissue)))
```

------------------------------------------------------------------------

<br>

###### Host transcriptomic {.unnumbered}

```{r echo = F}
mcfa_Wp$hostT %>%
  head(1000) %>%
  pretty_table(text = str_c("1000 first rows of total ", nrow(mcfa_Wp$hostT)))
```

------------------------------------------------------------------------

<br>

### Model performance

The below plot visualises the ratio of variance in the observed omic data explained by the model.

```{r model ve, fig.width = 15, fig.height = 3.5, out.width="70%"}
#--VARIANCE EXPLAINED---------------------
# combine VE data from shared and private model spaces
mcfa_varexpl_totals <- mcfa_varexpl_Fs %>% 
  colSums() %>% data.frame(shared = .) %>% rownames_to_column("layer") %>% 
  left_join(mcfa_varexpl_Fp %>% lapply(\(x) data.frame(private = colSums(x))) %>%  
    purrr::reduce(rbind) %>% mutate(layer = names(mcfa_varexpl_Fp)), by = "layer") %>% 
  
  # calculate residual
  mutate(residual = 1-shared-private) %>% 
  
  # pivot and reformat
  pivot_longer(-layer, names_to = "space", values_to = "var_exp") %>%
  mutate(layer = factor(layer, levels = c("hostT", "metaB_tissue",
                                          "metaB_digesta", "metaT", "metaG")),
         space = factor(space, levels = c("shared", "private", "residual")),
         label = str_c(ifelse(var_exp<0.01, round(var_exp*100, 1),
                                            round(var_exp*100, 0)), "%"))

# plot
mcfa_varexpl_totals %>% 
  ggplot(aes(var_exp*100, layer, fill = space)) +
  
  # bars
  geom_col(position = position_stack(reverse = T)) +
  
  # data labels
  geom_text(aes(label = label), size = 5,
            position = position_stack(reverse = T, vjust = 0.5)) +
  
  # titles
  labs(title = "variance explained by model space")+
  
  # fine-tune value range and colours
  scale_fill_manual(values = c("lightseagreen", "darkgoldenrod2", "steelblue3")) +
  scale_x_continuous(expand = c(0.005, 0)) +
  guides(fill = guide_legend(nrow = 1)) +
  
  # appearance
  theme(plot.title = element_text(size = 20, hjust = 0.5),
        strip.text = element_text(size = 15),
        
        legend.position = "top", legend.title.position = "top",
        legend.box.margin = margin(-5, 0, -15, 0, unit = "pt"),
        legend.title = element_blank(),
        legend.text = element_text(size = 18, vjust = 0.5),
        legend.key.spacing.x = unit(25, "pt"),
        
        plot.background = element_rect(fill = "white"),
        panel.background = element_rect(fill = "grey97"),
        strip.background = element_rect(fill = "grey87"),
        panel.grid = element_blank(),
        
        axis.ticks.y = element_blank(),
        axis.text = element_text(size = 15),
        axis.title = element_blank())
```

```{r sace mcfa ve figure, echo = F, eval = F}
# local
ggsave(file.path("figures", "mcfa_ve.png"), width = 15, height = 3.5)
ggsave(file.path("figures", "mcfa_ve.svg"), width = 15, height = 3.5)

# cloud
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/mcfa_ve.png", width = 15, height = 3.5)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/mcfa_ve.svg", width = 15, height = 3.5)
```

<font size="2">***Figure 2A**. Percent variance explained by model spaces for each input omic data layer. Style adapted from [[@brown2023]].*</font>

```{r mcfa ve figure vertical, eval = F, echo = F, fig.width=5, fig.height=5}
# small version for assembled figure 2
# plot
mcfa_varexpl_totals %>% 
  # shorten layer names
  mutate(layer = str_remove(layer, "igesta|issue"),
         layer = factor(layer, levels = c("metaG", "metaT",
                                          "metaB_d", "metaB_t", "hostT"))) %>% 
  # plot
  ggplot(aes(layer, var_exp*100, fill = space)) +
  # bars
  geom_col(position = position_stack(reverse = T)) +
  # data labels
  geom_text(aes(label = label), size = 4,
            position = position_stack(reverse = T, vjust = 0.5)) +
  # titles
  labs(fill = "variance explained by model space")+
  
  # fine-tune value range and colours
  scale_fill_manual(values = c("lightseagreen", "darkgoldenrod2", "steelblue3")) +
  scale_y_continuous(expand = c(0.005, 0)) +
  scale_x_discrete(expand = c(0.005, 0)) +
  guides(fill = guide_legend(nrow = 1)) +
  
  # appearance
  theme(strip.text = element_text(size = 15),
        
        legend.position = "top", legend.title.position = "top",
        legend.title = element_text(size = 15, hjust = 0.5),
        legend.text = element_text(size = 14, vjust = 0.5),
        legend.key.spacing.x = unit(15, "pt"),
        legend.margin = margin(0,0,-4,0),
        
        plot.background = element_rect(fill = "white"),
        panel.background = element_rect(fill = "grey97"),
        strip.background = element_rect(fill = "grey87"),
        panel.grid = element_blank(),
        
        axis.ticks.x = element_blank(),
        axis.text = element_text(size = 12),
        axis.title = element_blank())

# save
ggsave("figures/mcfa_ve_vertical.svg", width = 5, height = 5)
ggsave("figures/mcfa_ve_vertical.png", width = 5, height = 5)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/mcfa_ve_vertical.svg", width = 5, height = 5)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/mcfa_ve_vertical.png", width = 5, height = 5)
```

The shared model space explains most variance in the metabolomic layers. Combined with their resepctive private model spaces, around half of the variance in these layers are captured by the model. Variance in microbial abundances are not captured as well, but is still within the same range as the method author's own showcasing of the modelling approach [[@brown2023]].

Moreover, we can check how well the model fits with the covariates, i.e. the metadata on porcine diet and developmental stage for AcGGM introduction. For that, we perform two logistic regressions, one with a null model and one fitted model informed by the experimental metadata. The improvement in log likelihood from the former to the latter regression is used to calculate a pseudo-R2 value which informs on the fit of each model component - both the shared and the omic-specific private components - with the metadata. This step is done with Python using an adaptation of code from [[@brown2023]].

```{r logistic regression data transfer to python}
#--R: PREP FOR LOGISTIC REGRESSION WITH PYTHON------------------------
# combine private and shared model parts
mcfa_model <- do.call(cbind, c(mcfa_Fs, mcfa_Fp)) %>% 
  rename_with(\(x) str_remove(x, ".*\\."))

# transfer data to python session
# metadata
py_mcfa_sample_meta <- mcfa_sample_meta %>%
  # use data for relevant samples
  filter(sample %in% rownames(mcfa_model)) %>% 
  column_to_rownames("sample") %>% 
  # convert categorical to integer variables
  ## diet: control = 0, AcGGM = 1
  ## dev_stage: control = 0, post-weaning = 1, pre-weaning = 2
  mutate(across(diet:dev_stage, \(x) as.integer(x)-1)) %>% 
  r_to_py()

# model spaces
py_mcfa_Fs <- mcfa_Fs %>% r_to_py()
py_mcfa_Fp <- mcfa_Fp %>% r_to_py()
```

```{python}
#--PYTHON: LOGISTIC REGRESSION TO CALCULATE MODEL FIT WITH METADATA------------- 
# code in this chunk is adapted from Brown et al. (https://github.com/collinwa/MCFA)
import numpy as np
import pandas as pd
from sklearn import linear_model
from sklearn import metrics

pred_res = {}
# for each column in the metadata
for col in r.py_mcfa_sample_meta.columns:
  # mask: in column col, which rows are not NA
  mask = ~pd.isna(r.py_mcfa_sample_meta[col])
  scores = []
  # for each model component
  for factor in [r.py_mcfa_Fs] + list(r.py_mcfa_Fp.values()):
    # custom: if empty
    if factor.empty:
      r2_score = np.nan
    else:
      # if less than 13 unique variables in metadata column...
      if len(pd.unique(r.py_mcfa_sample_meta[col])) < 13:
        # intercept: null model target, all 1 given that value in col is not NA
        intercept = np.ones((sum(mask),1))
        
        # null model: all 1's vs. observed meta
        null_model = linear_model.LogisticRegression(penalty=None, max_iter=1000, fit_intercept=False).fit(intercept, r.py_mcfa_sample_meta[col][mask])
        
        # fitted model: observed data vs. observed meta
        fit_model = linear_model.LogisticRegression(penalty=None, max_iter=1000).fit(factor[mask], r.py_mcfa_sample_meta[col][mask])
        
        # log-likelihood of null model
        null_ll = metrics.log_loss(r.py_mcfa_sample_meta[col][mask], null_model.predict_proba(intercept), normalize=False)
        
        # log-likelihood of fitted model
        fit_ll = metrics.log_loss(r.py_mcfa_sample_meta[col][mask], fit_model.predict_proba(factor[mask]), normalize=False)
        
        # calculate (pseudo) r2
        r2_score = 1.0 - fit_ll/null_ll
      
      # if more than 13 unique observations, calculate another pseudo-r2  
      else:
        fit_model = linear.fit(factor[mask], r.py_mcfa_sample_meta[col][mask])
        r2_score = fit_model.score(factor[mask], r.py_mcfa_sample_meta[col][mask])
    
    # add this round of r2 (per metadata column, per data layer) to score list
    scores.append(r2_score)
  
  # add this round of r2 (per metadata column) to score dict
  pred_res[col] = scores

# finally, create dataframe of r2 values per data layer (rows) and metadata column (columns)
pred_res_1 = pd.DataFrame(pred_res, \
             index = ["shared", "hostT", "metaB_digesta", "metaB_tissue", "metaG", "metaT"])
```

```{r plot log reg model w metadata, fig.width=15, fig.height=4.65, out.width="70%"}
#--R: PLOT LOGISTIC REGRESSION RESULTS--------------------
# import results back from python session
mcfa_logres_r2 <- py$pred_res_1 %>%
  # fix NA values
  mutate(across(everything(), \(x) na_if(x, NaN))) %>% 
  rownames_to_column("layer") %>% 
  # reformat
  mutate(space = ifelse(layer == "shared", "shared", "private components"),
         space = factor(space, levels = c("shared", "private components")),
         layer = str_replace(layer, "shared", "component"),
         layer = str_remove(layer, "igesta|issue"),
         layer = factor(layer, levels = c("component", "metaG", "metaT", "metaB_d",
                                          "metaB_t", "hostT"))) %>% 
  pivot_longer(diet:dev_stage, names_to = "contrast", values_to = "r2") %>% 
  select(space, layer, contrast, r2)

# plot
mcfa_logres_r2 %>% 
  # change label colour depending on darkness of cell background
  mutate(label_colour = ifelse(r2 > 0.8, "white", "black")) %>% 
  
  ggplot() +
  # tiles
  geom_tile(aes(layer, contrast, fill = r2), height = 0.99, ) +
  # labels
  geom_text(aes(layer, contrast, label = round(r2, 4), colour = label_colour), size = 7) +
  # colour
  scale_colour_identity(guide = "none") +
  scale_fill_gradientn(breaks = c(0, 0.5, 1), limits = c(0, 1),
                       colours = c("grey99", "red", "darkred"), na.value = "grey90",
                       values = scales::rescale(c(0, 0.4, 0.6, 1))
                       ) +
  # legends
  guides(fill = guide_colourbar(title = "0                                                   1",
                                direction = "horizontal", order = 1, position = "top",
                                theme = theme(legend.key.height = unit(0.6, "cm"),
                                              legend.key.width = unit(10, "cm"),
                                              legend.title.position = "top",
                                legend.title = element_text(hjust = 0.5, vjust = -5,
                                                            size = 21)
                                              ))) +
  # remove space between facets
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  
  # facets and labels
  facet_nested(cols = vars(space, layer), scales = "free", space = "free") +
  labs(title = "fit with experimental variables (pseudo R2)", colour = element_blank()) +
  
  # appearance
  theme(legend.text = element_blank(),
        legend.box.margin = margin(-30, 0, 0 , 0, unit = "pt"),
        legend.key.spacing.x = unit(15, "pt"),
        legend.spacing.y = unit(30, "pt"),
        
        plot.background = element_rect(fill = "white"),
        plot.title = element_text(hjust = 0.5, size = 25),
        panel.background = element_rect(fill = "white"),
        panel.spacing = unit(2, "pt"),
        panel.grid = element_blank(),
        
        strip.background = element_rect(fill = "grey92"),
        strip.placement = "outside",
        strip.text = element_text(size = 20),
        
        axis.title = element_blank(),
        axis.text.y = element_text(angle = 90, hjust = 0.5),
        axis.text = element_text(size = 23),
        axis.text.x = element_blank(),
        axis.ticks = element_blank())
```

```{r save model metadata log reg plot, echo = F, eval = F}
# local
ggsave(file.path("figures", "mcfa_metadata_ve.png"), width = 15, height = 4.65)
ggsave(file.path("figures", "mcfa_metadata_ve.svg"), width = 15, height = 4.65)

# cloud
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/mcfa_metadata_ve.png", width = 15, height = 4.65)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/mcfa_metadata_ve.svg", width = 15, height = 4.65)
```

<font size="2">***Figure 2B**. Ratio of sample metadata variance explained by each learned model space, calculated as the improvement in log likelihood from a logistic regression null model to a fitted model. The pseudo-R2 value ranges from low (white) to high (dark red).*</font>

From this figure, we see that the model's shared space fits well with the developmental stage, more so than the simpler contrast between control and AcGGM-fed animals (contrast `diet`). Unsurprisingly, the private model spaces that are specific to each omic layer show an even better fit - all except for the host transcriptomics. While this pattern may have some basis in biology, for instance due to AcGGM being a microbiome-directed fibre and therefore any effect on the host being secondary, the main takeaway here is that the shared model space appears to fit with the experimental variable on porcine developmental stage for AcGGM introduction. We therefore use the weights fit to all features within this model space to select features for predicting interactions in our dataset.

<br>

### Feature selection {.tabset}

To facilitate the use of co-occurrence to predict host-microbiome interactions in our holo-omic dataset, we reduce the full feature space of `r nrow(metag)+nrow(metat)+nrow(metab)+nrow(metab)+nrow(hostt)` to cover only those molecular features with the most relevance for cross-omic data patterns.

```{r shared weights plot, fig.width=15, fig.height=10}
#--FEATURE SELECTION----------------------------
# gather shared weights from each omic layer
mcfa_top_shared_weights <- mcfa_Ws %>%
  do.call(rbind, .) %>% 
  rownames_to_column("name") %>% 
  # reformat
  separate_wider_delim(name, delim = fixed("."), names = c("layer", "feature"), too_many = "merge") %>%
  pivot_longer(starts_with("Ws"), names_to = "component", values_to = "weight") %>% 
  mutate(layer = factor(layer, levels = c("metaG", "metaT",
                                          "metaB_digesta", "metaB_tissue", "hostT"))) %>% 
  # identify 93rd percentile threshold per omic layer and model space
  group_by(layer, component) %>% 
  mutate(threshold = quantile(abs(weight), 0.93),
         # mark features with absolute weight above the threshold
         top = (abs(weight) > threshold)) %>% 
  ungroup() %>% 
  # add annotation (for host genes: if more annotations, use first)
  left_join(taxonomy %>% select(feature = MAG, annotation = taxonomy) %>% 
              rbind(annotations %>%
                      left_join(taxonomy %>% select(MAG, lowest), by = "MAG") %>% 
                      mutate(annotation = str_c(lowest, ": ",
                                ifelse(is.na(annotation), "unannotated", annotation))) %>% 
                      select(feature = gene, annotation)) %>% 
              rbind(metab_annotations %>% 
                      mutate(annotation = ifelse(is.na(name),
                                          ifelse(is.na(formula),
                                                 "unannotated", formula), name)) %>% 
                      select(feature = id, annotation)) %>% 
              rbind(host_annotations %>% 
                      mutate(annotation = ifelse(is.na(description),
                                          ifelse(is.na(class),
                                                 "unannotated", class), description)) %>% 
                      select(feature = gene, annotation) %>% 
                      slice_head(n = 1, by = "feature")), by = "feature") %>% 
  arrange(layer, desc(abs(weight)))
```

Setting the threshold at 7% (i.e., the 93rd percentile), we end up with a selection of `r mcfa_top_shared_weights %>% filter(top) %>% nrow()` features, which is a more manageable amount of features to predict interactions between - both with respect to computation time and subsequent network interpretation. The selected features from each omic layer are displayed in the below tabs.

<br>

#### Metagenomics {.unnumbered}

```{r echo = F}
mcfa_top_shared_weights %>% 
  filter(layer == "metaG", top) %>% select(-top, -component, -layer) %>% 
  pretty_table(text = str_c("Heaviest weighted metagenomic features in the shared MCFA model space (threshold ", round(.[[1,"threshold"]], 3), ")"))
```

------------------------------------------------------------------------

<br>

#### Metatranscriptomics {.unnumbered}

```{r echo = F}
mcfa_top_shared_weights %>% 
  filter(layer == "metaT", top) %>% 
  slice_max(weight, n = 1000) %>% select(-top, -component, -layer) %>% 
  pretty_table(text = str_c("Heaviest weighted metatranscriptomic features in the shared MCFA model space (threshold ", round(.[[1,"threshold"]], 3), ", top 1000 features)"))
```

------------------------------------------------------------------------

<br>

#### Digesta metabolomics {.unnumbered}

```{r echo = F}
mcfa_top_shared_weights %>%
  filter(layer == "metaB_digesta", top) %>% select(-top, -component, -layer) %>% 
  pretty_table(text = str_c("Heaviest weighted microbiome-associated metabolomic features in the shared MCFA model space (threshold ", round(.[[1,"threshold"]], 3), ")"))
```

------------------------------------------------------------------------

<br>

#### Tissue metabolomics {.unnumbered}

```{r echo = F}
mcfa_top_shared_weights %>%
  filter(layer == "metaB_tissue", top) %>% select(-top, -component, -layer) %>% 
  pretty_table(text = str_c("Heaviest weighted host-associated metabolomic features in the shared MCFA model space (threshold ", round(.[[1,"threshold"]], 3), ")"))
```

------------------------------------------------------------------------

<br>

#### Host transcriptomics {.unnumbered}

```{r echo = F}
mcfa_top_shared_weights %>% 
  filter(layer == "hostT", top) %>% select(-top, -component, -layer) %>% 
  slice_max(weight, n = 1000) %>% 
  pretty_table(text = str_c("Heaviest weighted host transcriptomic features in the shared MCFA model space (threshold ", round(.[[1,"threshold"]], 3), ", top 1000 features)"))
```

------------------------------------------------------------------------

<br>

## Co-occurrence

### Predicting interactions

Here, we extract omic data for the features identified as the most important for coordinated data patterns in the observed data, and accompanying metadata on porcine diet. These are provided as input for the software FlashWeave [[@tackmann2019]], which predicts direct interactions through co-occurrence.

```{r flashweave data prep}
#--EXTRACT DATA FOR SELECTED FEATURES-------------------
# NB: network based only on data from samples used in mcfa
# (i.e. common across all omic layers)
flashweave_features <- 
  # --metaG data----------------
  metag_vst %>%
  ## standardise sample names
  rename_with(\(x) substr(x, 1, 4)) %>%
  ## select relevant samples
  select(any_of(mcfa_samples$common)) %>% 
  rownames_to_column("feature") %>% 
  ## limit to top weigthed features in shared space
  filter(feature %in% (mcfa_top_shared_weights %>%
                         filter(top) %>% pull(feature))) %>%
  ## standardise feature names
  mutate(feature = str_c("metaG@", feature)) %>% 
  column_to_rownames("feature") %>% 
  
  # repeat same steps for each omic layer
  rbind(
    # metat
    metat_vst %>%
          rename_with(\(x) substr(x, 1, 4)) %>%
          select(any_of(mcfa_samples$common)) %>% 
          rownames_to_column("feature") %>% 
          filter(feature %in% (mcfa_top_shared_weights %>%
                                 filter(top) %>% pull(feature))) %>%
          mutate(feature = str_c("metaT@", feature)) %>% 
          column_to_rownames("feature")) %>% 
  rbind(
    # metab digesta
    metab_log2 %>%
          select(ends_with("I")) %>% 
          rename_with(\(x) substr(x, 1, 4)) %>%
          select(any_of(mcfa_samples$common)) %>% 
          rownames_to_column("feature") %>% 
          filter(feature %in% (mcfa_top_shared_weights %>%
                                 filter(top, grepl("digesta", layer)) %>%
                                 pull(feature))) %>%
          mutate(feature = str_c("metaB_digesta@", feature)) %>% 
          column_to_rownames("feature")) %>% 
    rbind(
      # metab tissue
      metab_log2 %>%
          select(ends_with("K")) %>% 
          rename_with(\(x) substr(x, 1, 4)) %>%
            select(any_of(mcfa_samples$common)) %>% 
          rownames_to_column("feature") %>% 
          filter(feature %in% (mcfa_top_shared_weights %>%
                                 filter(top, grepl("tissue", layer)) %>%
                                 pull(feature))) %>%
          mutate(feature = str_c("metaB_tissue@", feature)) %>% 
          column_to_rownames("feature")) %>% 
  rbind(
    # hostt
    hostt_vst %>%
          rename_with(\(x) substr(x, 1, 4)) %>%
          select(any_of(mcfa_samples$common)) %>% 
          rownames_to_column("feature") %>% 
          filter(feature %in% (mcfa_top_shared_weights %>%
                                 filter(top) %>% pull(feature))) %>%
          mutate(feature = str_c("hostT@", feature)) %>% 
          column_to_rownames("feature")) %>% 

  # remove features with NA
  filter(!(rownames(.) %in% (rowSums(.) %>% data.frame(sum = .) %>% 
                               filter(is.na(sum)) %>% rownames()))) %>% 
  # substitute negative values (original very low/zero counts) with 0
  mutate(across(everything(), \(x) ifelse(x < 0, 0, x))) %>% 
  t() %>% as.data.frame()

#--GET CORRESPONDING SAMPLE METADATA------------------
flashweave_samplemeta <- sample_meta %>%
  # standardise sample names
  mutate(sample = substr(sample, 1, 4)) %>%
  # extract relevant categories and samples
  distinct(sample, animal, diet, dev_stage) %>% 
  filter(sample %in% rownames(flashweave_features)) %>% 
  column_to_rownames("sample")

#--ADD METADATA AS COVARIATES------------------------
# turn categorical metadata to binary (e.g. diet_control: 1 for True, 0 for False)
flashweave_features <- flashweave_features %>% 
  # add one-hot coded variables
  cbind(flashweave_samplemeta %>% 
          rownames_to_column("sample") %>% 
          # diet: control and AcGGM
          mutate(onehot = 1) %>% 
          pivot_wider(names_from = "diet", values_from = "onehot",
                      names_prefix = "variable@diet_") %>% 
          # dev_stage: control, post-weaning, and pre-weaning
          mutate(onehot = 1) %>% 
          pivot_wider(names_from = "dev_stage", values_from = "onehot",
                      names_prefix = "variable@dev-stage_") %>% 
          select(-animal) %>% 
          # add zeros as "false"
          mutate(across(starts_with("variable"), \(x) replace_na(x, 0))) %>% 
          column_to_rownames("sample"))
```

We also extract feature annotations to import into the resulting network:

```{r heaviest features omic data extraction}
#--ASSEMBLE NETWORK METADATA FOR IMPORT INTO CYTOSCAPE----------------
flashweave_metadata <- data.frame(name = colnames(flashweave_features)) %>% 
  separate_wider_delim(name, delim = "@", cols_remove = F,
                       names = c("layer", "feature")) %>%
  left_join(# metaG
            taxonomy %>%
              transmute(feature = MAG, annotation = str_c(MAG, "  p__", phylum),
                        description = lowest) %>% 
            # metaT
            rbind(annotations %>%
                    left_join(taxonomy %>% select(MAG,lowest), by = "MAG") %>%
                    transmute(feature = gene, annotation,
                              description = str_c(MAG, "  ", lowest))) %>% 
            # metaB
            rbind(metab_annotations %>%
              transmute(feature = id,
                        annotation = str_c(ifelse(is.na(name),
                            ifelse(is.na(formula), "unannotated", formula),
                            ifelse(is.na(formula), name,
                                   str_c(name, " (", formula, ")")))),
                        description = flag)) %>%
            # hostT
            rbind(host_annotations %>%
              transmute(feature = gene,
                     annotation = ifelse(is.na(description), "unannotated",
                                         description),
                     description = str_c("id ", gene_id, ", ", class, " (",
                                ifelse(seq_type == "chromosome",
                                str_c("chr ", chromosome), str_c(seq_type)), ")"))),
            by = "feature", relationship = "many-to-many") %>%
  rowwise() %>% 
  # standardise labels
  mutate(annotation = ifelse(grepl("tRNA", feature), "tRNA", annotation),
         description = ifelse((layer == "metaT")&is.na(description),
                              pull(filter(taxonomy, MAG == word(feature, 1, sep = "_")),
                                   lowest), description),
         # experimental variables
         annotation = ifelse(layer == "variable",
                        str_replace(word(feature, 1, sep = "_"), "-", "_"), annotation),
         description = ifelse(layer == "variable",
                        word(feature, 2, sep = "_"), description)) %>%
  ungroup() %>% 
  mutate(node_label = str_c(layer, "\n", replace_na(annotation, "unannotated"), "\n",
                            replace_na(description, "unclassified")))
```

```{r save network files, eval = F, echo = F}
# local
flashweave_features %>% write.csv("data/processed/omics/flashweave_features.csv")
flashweave_samplemeta %>% write.csv("data/processed/metadata/flashweave_samplemeta.csv")
flashweave_metadata %>% write.csv("data/processed/metadata/flashweave_metadata.csv")

# github
flashweave_features %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/omics/flashweave_features.csv")
flashweave_samplemeta %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/flashweave_samplemeta.csv")
flashweave_metadata %>% write.csv("/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/flashweave_metadata.csv")
```

FlashWeave is implemented in Julia and was run using the terminal with the following code lines:

```{r run flashweave, eval = F}
# --SETUP------------------------------
# install julia
curl -fsSL https://install.julialang.org | sh

# update path to make julia findable
export PATH="$PATH:*download_location_for_julia*/.juliaup/bin"

# activate julia
julia

# install flashweave
import Pkg; Pkg.add("FlashWeave")

# --RUN FLASHWEAVE FOR FEATURE INTERACTION PREDICTION-------------------
using Flashweave

# save result as nw with this name
save_network("results/interaction_prediction/flashweave_coocurrence.gml",

 # co-occurrence nw of file with omic features and exp. variables as columns
 learn_network(Matrix(DataFrame(CSV.File("data/processed/omics/flashweave_features.csv",
                          # drop row names (row names not implemented in julia)
                          drop = [1]))),
      # load column names
      header = names(DataFrame(CSV.File("data/processed/omics/flashweave_features.csv",
                                        drop = [1]))),
      # identify which columns are exp. variables/covariates
      meta_mask = contains.(names(DataFrame(CSV.File("data/processed/omics/flashweave_features.csv", drop = [1]))), "variable"),
      # analysis settings: heterogeneous data (all caecal samples from same animals),
      # deactivated normalisation due to prior omic-specific standardisation
      sensitive = true, heterogeneous = false, n_obs_min = 7, normalize = false))
```

The resulting `.gml` file was imported as a network into Cytoscape (ver. 3.10.3) [[@shannon2003]]. The network metadata file created previously was imported as a node table. This updated node table was exported and then re-imported into the edge table, once to annotate source nodes and the second time to annotate target nodes.

<br>

### Interpreting the network

The full interaction network (from `flashweave_coocurrence.gml`, named "Full co-occurrence network" in the Cytoscape `.cys` session file on the [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}) contained 56,442 nodes and 70,888 edges:

```{r network image 1, echo = F, out.width="70%"}
include_graphics("figures/network_1_full.png")
```

<font size="2">*Full network of interactions predicted by FlashWeave.*</font>

<br>

The network contained one major connected component which comprised most of the nodes and edges. Other components were mostly clusters of associated microbial genes. Hence we turn our focus to the main component.

To get an overview of the types of interactions that were predicted, we extracted the edge table and imported it into R. We classified edges into three categories: if it connected two host-associated features (porcine genes or tissue metabolites), the interaction was labelled "host-host". An edge was classified as "microbiome-microbiome" if it connected two microbiome-associated features (MAGs, microbial genes, or digesta metabolites). Lastly, edges between one host- and one microbiome-associated feature were labelled "host-microbiome".

```{r flashweave edge overview, fig.width=15, fig.height=4, out.width="70%"}
#--PREDICTED INTERACTIONS--------------------------
# edges table from full co-occurrence network 
flashweave_edges <- read.csv("results/interaction_prediction/flashweave_cooccurrence_edgetable.csv") %>% 
  transmute(# source, target, and edge info
         source_layer, source_feature, target_layer, target_feature,
         weight, tplg_edgeBtwnn = EdgeBetweenness,
         
         # annotations
         source_annotation, source_description, source_label = source_node_label,
         target_annotation, target_description,target_label = target_node_label,
         
         # topology
         tplg_source_mainCC = as.logical(source_inMainCC),
         tplg_source_degree = source_Degree,
         tplg_source_avgShortPath = source_AverageShortestPath,
         tplg_source_btwnCentr = source_BetweennessCentrality,
         tplg_source_closeCentr = source_ClosenessCentrality,
         tplg_source_clustCoeff = source_ClusteringCoefficient,
         tplg_source_eccentricity = source_Eccentricity,
         tplg_source_ngbhConnect = source_NeighborhoodConnectivity,
         tplg_source_radiality = source_Radiality,
         tplg_source_stress = source_Stress,
         tplg_source_topolCoeff = source_TopologicalCoefficient,
         
         tplg_target_mainCC = as.logical(target_inMainCC),
         tplg_target_degree = target_Degree,
         tplg_target_avgShortPath = target_AverageShortestPath,
         tplg_target_btwnCentr = target_BetweennessCentrality,
         tplg_target_closeCentr = target_ClosenessCentrality,
         tplg_target_clustCoeff = target_ClusteringCoefficient,
         tplg_target_eccentricity = target_Eccentricity,
         tplg_target_ngbhConnect = target_NeighborhoodConnectivity,
         tplg_target_radiality = target_Radiality,
         tplg_target_stress = target_Stress,
         tplg_target_topolCoeff = target_TopologicalCoefficient) %>% 
  
  # infer interaction info
  mutate(cross = factor(ifelse(source_layer=="variable"|target_layer=="variable",
                              "exp_var",
                        ifelse(source_layer==target_layer,"within-omic",
                               "between-omic")),
                        levels = c("between-omic", "within-omic", "exp_var")),
         interaction = ifelse(cross == "exp_var", "exp_var",
                        ifelse((source_layer %in% c("hostT","metaB_tissue")&(
                                !target_layer %in% c("hostT","metaB_tissue")))|
                                !source_layer %in% c("hostT","metaB_tissue")&(
                                target_layer %in% c("hostT","metaB_tissue")),
                                "host-microbiome",
                        ifelse((source_layer %in% c("hostT","metaB_tissue"))&
                                 (target_layer %in% c("hostT","metaB_tissue")),
                               "host-host",
                        ifelse((!source_layer %in% c("hostT","metaB_tissue"))&
                                 (!target_layer %in% c("hostT","metaB_tissue")),
                               "microbiome-microbiome", NA)))),
         relationship = str_c(source_layer, "-", target_layer),
         abs_weight = abs(weight)) %>% 
  # order
  select(source_layer, source_feature, target_layer, target_feature,
         weight, abs_weight, cross, interaction, relationship, tplg_edgeBtwnn,
         source_annotation, source_description, source_label,
         target_annotation, target_description,target_label,
         matches("inMainCC"),
         starts_with("tplg_source"), starts_with("tplg_target"))

# plot overview
flashweave_edges %>%
  # drop variable interaction
  filter(!grepl("exp_var", interaction)) %>%
  # only include the main connected component
  filter(tplg_source_mainCC|tplg_target_mainCC) %>%
  
  # compute summary
  summarise(n = n(), .by = c(cross, interaction, relationship)) %>%
  
  # rearrange table for plot
  rbind(data.frame(cross = c("within-omic", "between-omic", "between-omic", "between-omic"),
             interaction = c("microbiome-microbiome", "microbiome-microbiome",
                             "host-microbiome", "host-microbiome"),
             relationship = c("metaG-metaG", "metaG-metaB_digesta",
                              "metaG-metaB_tissue",
                              "metaG-hostT"),
             n = 0)) %>%
  separate_wider_delim(relationship, delim = "-", names = c("x", "y")) %>% 
  mutate(across(x:y, \(x) str_replace(str_replace(x, "metaB_digesta", "metaB_d"), 
                              "metaB_tissue", "metaB_t") %>%
                  factor(levels = c("variable", "metaG", "metaT",
                                       "metaB_d", "metaB_t", "hostT")))) %>% 
  
  # plot
  ggplot() +
  # tiles
  geom_tile(aes(x, y, fill = interaction), alpha = 0.5, colour = "black") +
  # number labels
  geom_text(aes(x, y, label = n), size = 8, nudge_x = -0) +
  # colour scheme
  scale_fill_manual(values = c(exp_var = "grey90",
                               `host-host` = "pink",
                               `host-microbiome` = "palegreen",
                               `microbiome-microbiome` = "lightgoldenrod1")) +
  scale_y_discrete(limits = rev) +
  scale_x_discrete(position = "top") +
  
  # appearance
  theme(legend.position = "top",
        legend.title.position = "top",
        legend.title = element_text(size = 25, hjust = 0.5),
        legend.text = element_text(size = 20, vjust = 0.5),
        legend.key.spacing.x = unit(35, "pt"),
        legend.spacing.y = unit(30, "pt"),
        
        plot.background = element_rect(fill = "white"),
        panel.background = element_rect(fill = "white"),
        panel.spacing = unit(2, "pt"),
        panel.grid = element_blank(),
        
        axis.title = element_blank(),
        axis.text.y = element_text(angle = 0, hjust = 1),
        axis.text.x = element_text(angle = 0, hjust = 0.5),
        axis.text = element_text(size = 23),
        axis.ticks = element_blank())
```

```{r echo = F, eval = F}
# local
ggsave("figures/network_interaction_counts.png", width = 15, height = 4)
ggsave("figures/network_interaction_counts.svg", width = 15, height = 4)

# cloud
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/network_interaction_counts.png", width = 15, height = 4)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/network_interaction_counts.svg", width = 15, height = 4)
```

<font size="2">***Figure 2C**. Number of predicted interactions between the most important features for cross-omic data patterns, limited to the main component of the inferred co-occurrence network. Cell colour classifies the interaction as specific to host (pink) or microbiome (yellow) omic layers, or as crossing the holobiont axis (green).*</font>

<br>

The most interactions were predicted between metatranscriptomic features (i.e., microbial genes), resulting in the "microbiome-microbiome" category of interactions (yellow in **Fig. 2C**) being the most numerous. Still, over 2000 cross-kingdom interactions (green) were also predicted. We investigate these further by narrowing down the network in Cytoscape.

```{r network image 2, echo = F, out.width="70%"}
include_graphics("figures/network_2_mainCC.png")
```

<font size="2">*Main component in the full interaction network.*</font>

<br>

Mirroring the classification of edges done in R, we formulated an additional column in the edge table of our Cytoscape file named "interactions", reporting edges as "host-host", "microbiome-microbiome", or "host-microbiome". We used this column to extract all edges classified as a "host-microbiome" interaction:

```{r network image 3, echo = F, out.width="70%"}
include_graphics("figures/network_3_HMI.png")
```

<font size="2">*Host-microbiome interactions in the main component in the full interaction network.*</font>

<br>

A total of 2347 edges fell into this category, which connected 3276 nodes. A table listing all these interactions, plus the 40 host-microbiome interactions found outside the main connected component, is included below:

```{r flashweave HMI, echo = F}
# host-microbiome interactions (HMI)
flashweave_edges %>% 
  filter(grepl("host-micro", interaction)) %>% 
  select(source_layer, source_feature, source_annotation,
         weight,
         target_layer, target_feature, target_annotation) %>% 
  pretty_table(text = "Predicted interactions across the host-microbiome axis in the full co-occurrence network.")
```

<br>

To put these interactions into more context, we redid the subnetwork extraction process and included any edges that connected these 3276 nodes, irrespective of their classification:

```{r network image 4, echo = F, out.width="70%"}
include_graphics("figures/network_4_nodesWithHMI.png")
```

<font size="2">*Nodes with host-microbiome interactions in the main component in the full interaction network.*</font>

<br>

This network was included as Fig. 2D in the publication. Within this graph, we highlighted examples of predicted interactions that could be of interest for further investigation.

<br>

# Summary

In summary, we applied software developed for multi-omics on a holo-omic dataset to predict interactions between host- and microbiome-associated features with implied importance for coordinated data patterns in response to MDF administration. First, data-driven feature selection with MCFA narrowed down the feature space from over 800,000 to 56,000 features, circumventing issues of high-dimensionality and data heterogeneity often encountered in multi- and holo-omic analyses. Secondly, FlashWeave predicted direct interactions between the selected features while disregarding spurious associations driven by experimental and technical factors. The resulting co-occurrence network reiterated findings from our single-omic analyses and suggested novel features and interactions to consider for the continued study of the effect of AcGGM on pre-weaning piglets.

<br>

# References {#references .unnumbered}

::: {#refs}
:::

<br>

------------------------------------------------------------------------

# Supplementary {.tabset .unnumbered}

## S1: Porcine solid feed feed composition {.unnumbered}

The animals in the experimental feeding trial were given the same basal diet. DanMilk™ Supreme 1.0 (AB Neo, Denmark) milk replacement was given during the first four weeks of the experiment, followed by two weeks of solid feed (AgroSoft, Denmark) with composition as specified below (**Fig. S1**).

```{r basal feed, echo = F, out.width="50%"}
knitr::include_graphics("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S1_solid_feed.png")
```

<font size="2">***Figure S1.** Composition of the solid feed given during the final two weeks of the animal trial.*</font>

<br>

------------------------------------------------------------------------

## S3: Additional visualisations {.unnumbered .tabset}

### Trial metadata {.unnumbered}

```{r fig.width=15, fig.height=18, out.width="70%"}
# plot trial data
trial_meta %>% 
  left_join(sample_meta %>% distinct(animal, diet, dev_stage), by = "animal") %>% 
  
  # reformat
  pivot_longer(c(weight_kg, milk_ml:score_faeces_1_5),
               names_to = "measure", values_to = "value") %>% 
  mutate(measure = str_replace(str_replace(str_replace(str_replace(str_replace(str_replace(str_replace(str_replace(measure,
          "acggm_g", "feed administered: AcGGM supplement [g]"),
          "feed_g", "feed administered: solid diet [g]"),
          "milk_ml", "feed administered: liquid diet [mL]"),
          "score_appetite_1_2", "score: appetite [1 normal, 2 leftover feed]"),
          "score_clinical_1_3", "score: clinical  [1 normal, 3 depressed]"),
          "score_dehydration_1_2", "score: dehydration [1 normal, 2 low skin turgor]"),
          "score_faeces_1_5", "score: faeces [1 solid, 5 diarrhoea]"),
          "weight_kg", "body weight [kg]")) %>% 
  filter(!is.na(day)) %>% 
  
  # plot
  ggplot() +
  
  # boxplots and points
  geom_boxplot(aes(as.factor(day), value, fill = dev_stage, colour = dev_stage),
               alpha = 0.7, outliers = F) +
  geom_point(aes(as.factor(day), value, colour = dev_stage),
             size = 1, position = position_jitterdodge(jitter.width = 0.3)) +
  scale_fill_manual(values = annot_colours$dev_stage) +
  scale_colour_manual(values = darken(annot_colours$dev_stage, 0.2)) +
  guides(colour = guide_legend(title = "AcGGM introduction"),
         fill = guide_legend(title = "AcGGM introduction")) +
  
  # milestones
  geom_vline(aes(xintercept = 14.5), linetype = "dotted", alpha = 0.5) +
  annotate("text", x = 14.6, y = Inf, hjust = 0, vjust = 1.3, alpha = 0.3,
           label = "pre-weaning AcGGM introduction", size = 3) +
  
  geom_vline(aes(xintercept = 17.5), linetype = "dotted", alpha = 0.5) +
  annotate("text", x = 17.6, y = Inf, hjust = 0, vjust = 2.8, alpha = 0.3,
           label = "weaning started", size = 3) +
  
  geom_vline(aes(xintercept = 26.5), linetype = "dotted", alpha = 0.5) +
  annotate("text", x = 26.6, y = Inf, hjust = 0, vjust = 1.1, alpha = 0.3,
           label = "weaned\npost-weaning AcGGM introduction",
           lineheight = 0.85, size = 3) +
  
  labs(x = "trial day") +
  
  facet_wrap2(vars(measure), ncol = 1, scales = "free") +
  
  # plot appearance
  theme(axis.title = element_text(size = 15),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 12),
        strip.text = element_text(size = 15),
        
        legend.position = "top",
        legend.title.position = "top",
        legend.title = element_text(size = 15, hjust = 0.5),
        legend.text = element_text(size = 14, vjust = 0.5),
        legend.spacing.x = unit(50, "pt"),
        legend.key.spacing.x = unit(15, "pt"),
        
        panel.background = element_rect(fill = "grey97"),
        plot.background = element_rect(fill = "white"),
        strip.background = element_rect(fill = "grey87"),
        panel.grid = element_blank())
```

```{r save trial data figure, eval = F, echo = F}
# locally
ggsave("figures/supplements/S3-1_trial_meta.png", width = 15, height = 18)
ggsave("figures/supplements/S3-1_trial_meta.svg", width = 15, height = 18)

# cloud
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-1_trial_meta.png", width = 15, height = 18)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-1_trial_meta.svg", width = 15, height = 18)
```

<font size="2">***Figure S3.1.** Animal performance and administered feed throughout the feeding trial.*</font>

------------------------------------------------------------------------

<br>

### Phylogenetic tree {.unnumbered}

First, the tree is reformatted to use taxonomy as tip labels, and only the bacterial MAGs with sufficient quality are kept:

```{r phylo tree filter}
# --TREE METADATA-----------------------
# implement simplified MAG names
tree_labels <- data.frame(label = tree_raw$tip.label) %>% filter(label %in% rownames(metag_raw)) %>% 
  left_join(new_names %>% select(label = old_MAG, MAG = new_MAG) %>% distinct(), by = "label") %>% 
  # remove bad quality MAGs (without simplified MAG name)
  filter(!is.na(MAG)) %>%
  # add taxonomy
  left_join(taxonomy %>% select(MAG, domain:species, lowest), by = "MAG") %>%
  # string to factor for correct order
  mutate(domain = factor(domain, levels = c("Archaea", "Bacteria")),
         
         phylum = factor(phylum, levels = c("Bacillota", "Cyanobacteriota",
                            "Patescibacteria","Elusimicrobiota", "Bacteroidota",
                            "Pseudomonadota", "Campylobacterota", "Deferribacterota",
                            "Desulfobacterota", "Myxococcota", "Verrucomicrobiota",
                            "Spirochaetota")),
         
         class = factor(class, levels = c("Clostridia", "Negativicutes", "Peptococcia",
                            "Bacilli", "Vampirovibrionia", "Elusimicrobia",
                            "Bacteroidia", "Gammaproteobacteria", "Campylobacteria",
                            "Deferribacteres", "Desulfovibrionia", "Lentisphaeria",
                            "Spirochaetia")),
         
         order = factor(order, levels = c("Lachnospirales", "Oscillospirales",
                            "UBA1381", "TANB77", "Christensenellales",
                            "Peptostreptococcales", "Clostridiales",
                            "Acidaminococcales", "Veillonellales", "Selenomonadales",
                            "Peptococcales", "Erysipelotrichales","RFN20", "RF39",
                            "Haloplasmatales", "Lactobacillales", "Gastranaerophilales",
                            "Saccharimonadales", "Elusimicrobiales", "Bacteroidales",
                            "Enterobacterales", "Burkholderiales", "Campylobacterales",
                            "Deferribacterales", "Desulfovibrionales", "UBA4248",
                            "Victivallales", "Sphaerochaetales", "Treponematales")))
                                          

# filter tree to only contain present, good-quality MAGs
tree <- tree_raw %>% 
  drop.tip(.$tip.label[!tree_raw$tip.label %in% tree_labels$label])

# relabel tree tips with taxonomy
tree$tip.label <- tree_labels %>%
  column_to_rownames("label") %>% .[tree$tip.label,"lowest"]
```

```{r save filtered tree, eval = F, include = F}
write.tree(tree, "data/processed/metadata/metaG_phylogenetic.tree")
write.tree(tree, "/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/metaG_phylogenetic.tree")
```

The final `.tree` file is included in the `data/processed/metadata` directory on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}. Next, select metadata points are assembled for each population represented in the tree:

```{r phylo tree metadata}
# --TOTAL TRANSCRIPTOMIC ACTIVITY------------------ 
# sum transcriptomic reads across all genes for each MAG
metat_magwise <- metat %>%
  # extract MAG names
  rownames_to_column("gene") %>% 
  separate_wider_delim(gene, delim = "_", names = c("MAG", "contig", "gene")) %>% 
  select(-contig, -gene) %>% 
  
  # summarise read counts per sample per MAG
  group_by(MAG) %>% 
  summarise(across(matches("^C[0-9]"), sum)) %>% 
  column_to_rownames("MAG")

# run differential expression analysis
# --diet-----------------------------
## deseq object
{metat_magwise_dds_diet <- metat_magwise %>%
    select(any_of(sample_meta %>% pull(sample))) %>% 
    DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "metaT"),
                           design = ~diet)
## ensure correct reference level is used
metat_magwise_dds_diet$diet <- relevel(metat_magwise_dds_diet$diet, ref = "control")

## run analysis
metat_magwise_dds_diet <- metat_magwise_dds_diet %>% DESeq()}

## extract significant results
metat_magwise_dea_diet_signif <- results(metat_magwise_dds_diet,
                                             contrast = c("diet", "AcGGM", "control")) %>%
  as.data.frame() %>% rownames_to_column("MAG") %>% 
  mutate(category = "diet", contrast = "control_v_AcGGM") %>% 
  
  ## significance filtering
  # filter(baseMean > threshold_baseMean) %>% 
  filter(abs(log2FoldChange) > threshold_lfc,
         padj < threshold_padj)

# --dev stage------------------------
## deseq object
{metat_magwise_dds_devstage <- metat_magwise %>%
    select(any_of(sample_meta %>% pull(sample))) %>% 
    DESeqDataSetFromMatrix(colData = sample_meta %>% filter(layer == "metaT"),
                           design = ~dev_stage)
## ensure correct reference level is used
metat_magwise_dds_devstage$dev_stage <- relevel(metat_magwise_dds_devstage$dev_stage, ref = "control")

## run analysis
metat_magwise_dds_devstage <- metat_magwise_dds_devstage %>% DESeq()}

## extract significant results
metat_magwise_dea_devstage_signif <- results(metat_magwise_dds_devstage,
                                             contrast = c("dev_stage", "pre-weaning", "post-weaning")) %>%
  as.data.frame() %>% rownames_to_column("MAG") %>% 
  mutate(category = "dev_stage", contrast = "post-weaning_v_pre-weaning") %>% 
  
  ## significance filtering
  # filter(baseMean > threshold_baseMean) %>% 
  filter(abs(log2FoldChange) > threshold_lfc,
         padj < threshold_padj)

## apply vst
metat_magwise_vst <- metat_magwise_dds_devstage %>%
  varianceStabilizingTransformation() %>% 
  assay() %>% as.data.frame()


# --MAG QUALITY METADATA---------------------
tree_metadata <- tree_labels %>%
  
  # MAG lengths (num. bases)
  left_join(read.csv("data/processed/metadata/raw_metaG_contigLengths.csv", row.names = 1) %>%
            separate_wider_delim(contig, delim = "@", names = c("label", "contig")) %>% 
            group_by(label) %>% 
            mutate(mag_length = sum(length)) %>% 
            ungroup() %>% distinct(label, mag_length), by = "label") %>% 
  
  # completeness as maximum covered fraction per MAG
  left_join(metag_covfrac %>% apply(1, max) %>% data.frame(completeness = .) %>%
              rownames_to_column("label"), by = "label") %>% 
  
# --INCORPORATE TOTAL TRANSCRIPTOMIC ACTIVITY------------------ 
  # add MAG-wise metaT VST expression levels and DEA diet and devstage results
  # counts - replace negative log2 values (i.e. counts below 1) with 0
  left_join(metat_magwise_vst %>%
              mutate(across(everything(), \(x) ifelse(x < 0, 0, x))) %>%
              rownames_to_column("MAG"), by = "MAG") %>% 
  # test results
  left_join(metat_magwise_dea_diet_signif %>% 
              select(MAG, log2FoldChange_diet = log2FoldChange,
                     padj_diet = padj, baseMean_diet = baseMean), by = "MAG") %>% 
  
  left_join(metat_magwise_dea_devstage_signif %>%
              select(MAG, log2FoldChange_devstage = log2FoldChange,
                     padj_devstage = padj, baseMean_devstage = baseMean), by = "MAG") %>% 
  # extract test outcomes
  mutate(significant_diet = ifelse(is.na(log2FoldChange_diet), "", "*"),
         significant_devstage = ifelse(is.na(log2FoldChange_devstage), "", "*"),
         direction_diet = ifelse(significant_diet == "", "",
                            ifelse(log2FoldChange_diet > 0, "AcGGM", "control")),
         direction_devstage = ifelse(significant_devstage == "", "",
                  ifelse(log2FoldChange_devstage > 0, "pre-weaning", "post-weaning"))) %>% 
  # pivot count data
  pivot_longer(matches("^C[0-9]{3}"), names_to = "sample", values_to = "metaT") %>% 
  
  # add sample metadata
  left_join(sample_meta %>% select(sample, diet, dev_stage), by = "sample") %>% 
  
  # summarise metaT counts per MAG and diet/development stage
  group_by(MAG, diet) %>% 
  mutate(metaT_diet = sum(metaT)) %>% 
  ungroup() %>% 
  
  group_by(MAG, dev_stage) %>% 
  mutate(metaT_devstage = sum(metaT)) %>% 
  ungroup() %>% 
  select(-sample, -metaT) %>% distinct()
  
  # disregard control sample metaT data
  # filter(dev_stage != "control")

# remove intermediate objects
rm(metat_magwise, metat_magwise_dds_diet, metat_magwise_dea_diet_signif,
   metat_magwise_dds_devstage, metat_magwise_dea_devstage_signif)
```

```{r save tree metadata, eval = F, include = F}
write.csv(tree_metadata, "data/processed/metadata/metaG_phylogenetic_meta.csv")
write.csv(tree_metadata, "/Users/jennymerkesvik/Documents/GitHub/3domics_wp3-2/data/processed/metadata/metaG_phylogenetic_meta.csv")
```

The phylogenetic tree metadata is included in the directory `data/processed/metadata` on [GitHub](https://github.com/jennymerkesvik/3domics_wp3-2){target="_blank"}. The tree with accompanying metadata represented as surrounding rings may then be plotted:

```{r plot phylo tree, fig.width = 15, fig.height = 13, eval = F}
# --PLOT TREE----------------------------------
# taxonomic level to annotate by
level <- tax_levels[4]
# contrast <- "diet|control|AcGGM"
contrast <- "dev.*tage|pre|post"
contrast2 <- "diet|control|AcGGM"

# base tree
tree %>% 
  force.ultrametric(method = "extend") %>% 
  ggtree(layout = "fan", open.angle = 5, size = 0.2) %>% 
  rotate_tree(91) %<+%
  
  # metadata
  tree_metadata %>% 
  
  ## taxonomy ring
  gheatmap(tree_metadata %>% select(all_of(level), lowest) %>%
             distinct() %>% column_to_rownames("lowest"),
           width = 0.1, offset = 1.25, font.size = 0, color = "white") +
  scale_fill_manual(name = str_c("C: ", level, " classification"),
                    values = annot_colours[[level]],
                    breaks = levels(tree_metadata[[level]]),
                    guide = guide_legend(ncol = 1, order = 1, position = "right",
                                         override.aes = list(size = 8),
                    theme = theme(legend.title = element_text(hjust = 0),
                                  legend.box.spacing = unit(-6, "cm"),
                                  legend.margin = margin(10, 10, 10, 10)))) +
  annotate("text", label = "    C", x = 4.03, y = 0.5, size = 8) +
  
  ## tip labels
  geom_tiplab(geom = "text", size = 1.6, hjust = 0, offset = 0.02) +

  ## genome size and covered fraction
  new_scale_fill() +
  geom_fruit(data = tree_metadata %>% select(-any_of(matches("diet|dev.*tage"))) %>% distinct(),
             aes(x = tree_metadata %>% select(-any_of(matches("diet|dev.*tage"))) %>%
                   distinct() %>% pull(mag_length),
                 y = lowest,
                 fill = tree_metadata %>% select(-any_of(matches("diet|dev.*tage"))) %>%
                   distinct() %>% pull(completeness) * 100),
             geom = geom_bar, stat = "identity",
             colour = "grey1", size = 0.1, width = 0.6,
             offset = 0.68, pwidth = 0.2) +
  annotate("text", label = "    B", x = 4.43, y = 0.35, size = 8) +
  scale_fill_gradientn(name = "B:  metagenome-assembled genomes",
                       colours = c("red3", "lightyellow", "blue4"),
                       breaks = c(80, 90, 100), limits = c(80, 100),
                       labels = c("80%", "completeness", "100%"),
                       guide = guide_colourbar(direction = "horizontal", order = 3,
                                               position = "top",
                       theme = theme(legend.title = element_text(hjust = 0.1),
                                     legend.margin = margin(0, 0, 0, 120),
                                     legend.key.width = unit(7.2, "cm"),
                                     legend.key.height = unit(0.6, "cm")))) +

  ## dummy layer to get legend desciption for bar height
  new_scale_fill() +
  geom_fruit(data = tree_metadata %>%
               select(-any_of(matches("diet|dev.*tage"))) %>% distinct(),
             aes(x = 0, y = lowest, fill = NA), geom = geom_point, alpha = 0) +
  scale_fill_manual(name = "bar height: genome size",
                    values = c(`NA` = "grey99"),
                      guide = guide_legend(order = 4, position = "top",
                      theme = theme(legend.title = element_text(size = 18, face = "plain"),
                                    legend.text = element_text(size = 0),
                                    legend.margin = margin(24, 10, 0, -140)))) +
  
  
  ## significance test for expression data
  new_scale_color() +
  geom_fruit(data = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast))) %>% distinct() %>%
               # replace diet or dev_stage column name with "contrast"
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               # include just relevant rows (only for dev_stage)
               filter(grepl(contrast, contrasts)),
             aes(x = 0, y = lowest,
                 label = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast))) %>% distinct() %>%
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast, contrasts)) %>%
                 pull(matches("significant")),
                 colour = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast))) %>% distinct() %>%
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast, contrasts)) %>%
                 pull(matches("direction"))),
             geom = geom_text, size = 6, vjust = 0.85, hjust = 0.5,
             offset = -0.04) +
  scale_colour_manual(name = "                   significantly higher in",
                      values = darken(annot_colours[[names(annot_colours)[grepl(word(contrast, 1, sep = "\\|"), names(annot_colours))]]][grepl(word(contrast, 2, 3, sep = "\\|"), names(annot_colours[[names(annot_colours)[grepl(word(contrast, 1, sep = "\\|"), names(annot_colours))]]]))], 0.2),
                      guide = guide_legend(order = 2, position = "top", direction = "vertical",
                                           override.aes = list(size = 8, label = "*"),
                      theme = theme(legend.title = element_text(size = 20),
                                    legend.margin = margin(8, -80, 0, 10),
                                    legend.text = element_text(vjust = 1),
                                    legend.key.spacing.y = unit(-1, "pt")))) +

  ## gene expression counts
  new_scale_fill() +
  geom_fruit(data = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast))) %>% 
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast, contrasts)) %>% 
               mutate(contrasts = str_replace(contrasts, "weaning", "weaning AcGGM")) %>% 
               distinct(), 
             aes(x = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast))) %>% 
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast, contrasts)) %>% 
               mutate(contrasts = str_replace(contrasts, "weaning", "weaning AcGGM")) %>% 
               distinct() %>% select(matches("metaT") & matches(contrast)) %>% .[[1]],
                 y = lowest,
                 fill = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast))) %>% 
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast, contrasts)) %>% 
               mutate(contrasts = str_replace(contrasts, "weaning", "weaning AcGGM")) %>% 
               distinct() %>% pull(contrasts)),
             geom = geom_col,
             colour = "grey1", size = 0.2, width = 0.6,
             offset = 0.03, pwidth = 0.3) +
  annotate("text", label = "    A", x = 5.2, y = 0.2, size = 8) +
  scale_fill_manual(name = "A:  gene expression",
                    values = c(control = annot_colours$diet[["control"]],
                         AcGGM = annot_colours$diet[["AcGGM"]],
                         `post-weaning AcGGM` = annot_colours$dev_stage[["post-weaning"]],
                         `pre-weaning AcGGM` = annot_colours$dev_stage[["pre-weaning"]]),
                    guide = guide_legend(order = 1, position = "top", direction = "vertical",
                                         override.aes = list(),
                    theme = theme(legend.margin = margin(10, -10, 10, 10)))) +
  
  
  # ADDITIONAL EXPR DATA AND TEST
  ## significance test for expression data
  new_scale_color() +
  geom_fruit(data = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast2))) %>% distinct() %>%
               # replace diet or dev_stage column name with "contrast"
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast2))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               # include just relevant rows (only for dev_stage)
               filter(grepl(contrast2, contrasts)),
             aes(x = 0, y = lowest,
                 label = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast2))) %>% distinct() %>%
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast2))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast2, contrasts)) %>%
                 pull(matches("significant")),
                 colour = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast2))) %>% distinct() %>%
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast2))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast2, contrasts)) %>%
                 pull(matches("direction"))),
             geom = geom_text, size = 6, vjust = 0.85, hjust = 0.5,
             offset = -0.04) +
  scale_colour_manual(name = "",
                      values = darken(annot_colours[[names(annot_colours)[grepl(word(contrast2, 1, sep = "\\|"), names(annot_colours))]]][grepl(word(contrast2, 2, 3, sep = "\\|"), names(annot_colours[[names(annot_colours)[grepl(word(contrast2, 1, sep = "\\|"), names(annot_colours))]]]))], 0.2),
                      guide = guide_legend(order = 2, position = "top", direction = "vertical",
                                           override.aes = list(size = 8, label = "*"),
                      theme = theme(legend.title = element_text(size = 20),
                                    legend.margin = margin(8, -110, 0, -10),
                                    legend.text = element_text(vjust = 1),
                                    legend.key.spacing.y = unit(-1, "pt")))) +

  ## gene expression counts
  new_scale_fill() +
  geom_fruit(data = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast2))) %>% 
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast2))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast2, contrasts)) %>% 
               mutate(contrasts = str_replace(contrasts, "weaning", "weaning AcGGM")) %>% 
               distinct(), 
             aes(x = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast2))) %>% 
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast2))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast2, contrasts)) %>% 
               mutate(contrasts = str_replace(contrasts, "weaning", "weaning AcGGM")) %>% 
               distinct() %>% select(matches("metaT") & matches(contrast2)) %>% .[[1]],
                 y = lowest,
                 fill = tree_metadata %>%
               select(label:completeness, any_of(matches(contrast2))) %>% 
               rename_with(~paste(.,"contrasts"), .cols = matches(str_c("^",contrast2))) %>% 
               rename_with(~word(., 2), .cols = matches(" contrasts")) %>% 
               filter(grepl(contrast2, contrasts)) %>% 
               mutate(contrasts = str_replace(contrasts, "weaning", "weaning AcGGM")) %>% 
               distinct() %>% pull(contrasts)),
             geom = geom_col,
             colour = "grey1", size = 0.2, width = 0.6,
             offset = 0.03, pwidth = 0.3) +
  scale_fill_manual(name = "",
                    values = c(control = annot_colours$diet[["control"]],
                         AcGGM = annot_colours$diet[["AcGGM"]],
                         `post-weaning AcGGM` = annot_colours$dev_stage[["post-weaning"]],
                         `pre-weaning AcGGM` = annot_colours$dev_stage[["pre-weaning"]]),
                    guide = guide_legend(order = 1, position = "top", direction = "vertical",
                                         override.aes = list(),
                    theme = theme(legend.margin = margin(10, -100, 10, 10)))) +
  
  
  # theme
  theme(legend.justification.top = c(1, 1),
        legend.justification.right = c(1, 0.55),
        legend.location = "plot",
        legend.box.spacing = unit(-3, "cm"),
        legend.title = element_text(hjust = 0.5, angle = 0, size = 22, face = "bold"),
        legend.title.position = "top",
        legend.text = element_text(size = 20),
        legend.key.spacing.y = unit(3, "pt"),
        legend.box.background = element_rect(colour = "grey85", fill = "grey99", ),
        legend.box.just = "center",
        legend.background = element_blank(),
        axis.ticks.y = element_blank(),
        plot.margin = unit(c(-1, 0.1, -4.2, -3.8), "cm"))
```

```{r save phylo tree, include = F, eval = F}
# local
ggsave("figures/supplements/S3-2_phylo_tree.svg", width = 15, height = 13)
ggsave("figures/supplements/S3-2_phylo_tree.png", width = 15, height = 13)

# cloud
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-2_phylo_tree.png", width = 15, height = 13)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-2_phylo_tree.svg", width = 15, height = 13)
```

```{r show phylo tree, out.width="60%", echo = F}
level <- tax_levels[[4]]
knitr::include_graphics("figures/supplements/S3-2_phylo_tree.png")
```

<font size="2">***Figure S3.2**. Phylogenetic tree of the `r nrow(taxonomy %>% filter(domain=="Bacteria"))` bacterial populations in the MAG catalogue. The most specific taxonomic classification is used as branch labels. Repeated taxon identifiers are numerated by order of appearance. **A)** Sum of metatranscriptomic reads mapped to each MAG in animals fed acetylated galactoglucomannan (AcGGM), split into fibre introduction with or without AcGGM (outer ring) and before and after weaning (inner ring). Significant differences (LFC\>1, FDR p-value\<0.05) in activity levels are marked with asterisks below each bar, with colour indicating which of diet group had the most transcriptionally active population of the MAG. **B)** Genome sizes (bar height) and completeness (colour) of MAGs. **C)** Taxonomic classification of MAGs on the `r level` level.*</font>

------------------------------------------------------------------------

<br>

### Differentially observed features {.tabset .unnumbered}

Following differential abundance and expression analyses, several metagenome-assembled genomes, metabolites, and microbial and host genes differed significantly (absolute log2FoldChange \> 1, false discovery rate-adjusted p-value \< 0.05) across the various contrasts. These features have been visualised in the tabs below. Under *Metagenomics*, **Figs. S3.3-4** cover microbial populations whose abundance varied across diet groups and development stage for AcGGM introduction, respectively. Under *Host transcriptomics*, **Figs. S2.4-5** show host genes with different expression across diet group and development stage, respectively.

```{r suppl 3 fig settings, include = F}
facets_per_row <- 4
facetrows_per_page <- 6
```

#### Metagenomics {.tabset .unnumbered}

##### Diet group {.unnumbered}

```{r fig s3-3 paged, fig.width = 15, fig.height = 19.6, eval = F, results = F, fig.show = "hide"}
# --PLOTTING ALL DIFFERENTIALLY ABUNDANT MAGs: DIET, PAGED VIEW--------------
tmp <- metag_daa_signif %>% 
  filter(category == "diet") %>% 
  arrange(desc(log2FoldChange)) %>% 
  mutate(label = factor(label, levels = unique(label))) %>% 
  select(category, contrast, MAG, log2FoldChange, padj, baseMean,
         label, taxonomy, phylum, lowest,
         bar_start, bar_stop, bar_label, bar_y) %>% 
  left_join(metag_vst %>% rownames_to_column("MAG") %>%
              pivot_longer(-MAG, names_to = "sample", values_to = "vst"), by = "MAG") %>% 
  left_join(sample_meta %>% filter(layer == "metaG"), by = "sample") %>% 
  group_by(label) %>%
  mutate(num = as.integer(label)-1,
         page = ifelse(num < facets_per_row*(facetrows_per_page-1), 0,
                       floor((num-facets_per_row*(facetrows_per_page-1))/
                                    (facets_per_row*facetrows_per_page))+1),
         num = num +1,
         page = page +1) %>% 
  ungroup()


for(p in unique(tmp$page)) {
  tmp %>%
    # subset data
    filter(page == p) %>% 
    
    # plot
    ggplot() +
    
    # boxplots
    geom_boxplot(aes(diet, vst, fill = diet, colour = diet), outliers = F, alpha = 0.7) +
    scale_colour_manual(values = darken(annot_colours$diet, 0.2)) +
    scale_fill_manual(values = annot_colours$diet) +
    guides(fill = guide_legend(title = "diet group", order = 1, ncol = 1),
           colour = guide_legend(title = "diet group", order = 1, ncol = 1)) +
    
    # points
    new_scale_colour() +
    geom_point(aes(diet, vst, shape = type, colour = dev_stage), size = 4,
               position = position_jitterdodge(jitter.width = 0.3, dodge.width = 0.7)) +
    scale_colour_manual(values = darken(annot_colours$dev_stage, 0.2)) +
    guides(colour = guide_legend(title = "AcGGM introduction", order = 3, ncol = 1,
                               override.aes = list(shape = 15, size = 5)),
           shape = guide_none()) +
    
    # significance bars
    geom_signif(data = tmp %>% filter(page == p),
                aes(xmin = bar_start, xmax = bar_stop,
                    y_position = bar_y, annotations = bar_label),
                manual = T, colour = "grey30",
                textsize = 4.5, vjust = 1.4, size = 0.3, tip_length = 0.05) +
    
    # facets
    facet_wrap2(vars(fct_inorder(label)), ncol = 4, scales = "free",
                strip = strip_themed(background_x = elem_list_rect(fill = alpha(annot_colours$phylum[tmp %>% filter(page == p) %>% arrange(desc(log2FoldChange)) %>% mutate(label = factor(label)) %>% select(label, phylum) %>% distinct() %>% pull(phylum)], 0.6)))) +
    
    # dummy points to generate facet strip colour legend
      new_scale_colour() +
      geom_point(aes(Inf, Inf, colour = phylum), alpha = 0, shape = 15) +
      scale_colour_manual(values = annot_colours$phylum,
                          breaks = tmp %>% filter(page == p) %>%
                            distinct(phylum) %>% pull(phylum) %>% sort()) +
      guides(colour = guide_legend(title = "phylum", order = 4, nrow = 3,
                                   override.aes = list(alpha = 1, size = 6))) +
    # text labels
    labs(title = str_c("Differentially abundant populations: diet group (", p, "/", max(tmp$page), ")"),
         x = element_blank(),
         y = "abundance (vst)") +
    
    # appearance
    theme(axis.title = element_text(size = 15),
          axis.text = element_text(size = 13),
          
          strip.text = element_text(size = 13),
          plot.title = element_text(hjust = 0.5, size = 17, face = "bold"),
          
          legend.position = "top",
          legend.title.position = "top",
          legend.title = element_text(size = 15, hjust = 0.5),
          legend.text = element_text(size = 14, vjust = 0.5),
          legend.spacing.x = unit(50, "pt"),
          legend.key.spacing.x = unit(15, "pt"),
          
          panel.background = element_rect(fill = "grey97"),
          plot.background = element_rect(fill = "white"),
          strip.background = element_rect(fill = "grey87"),
          panel.grid = element_blank())
  
  # save figure
  ## compute height based on num. facet rows
  height <- 1.8 + 2.96667 * ceiling(nrow(distinct(tmp %>% filter(page == p) %>% select(label)))/facets_per_row)
  
  ## locallysupplement
  ggsave(str_c("figures/supplements/S3-3_metaG_diff_abundant_diet_", p, "of", max(tmp$page),".svg"),
         width = 15, height = height, limitsize = F)
  ggsave(str_c("figures/supplements/S3-3_metaG_diff_abundant_diet_", p, "of", max(tmp$page),".png"),
         width = 15, height = height, limitsize = F)

  # cloud
  ggsave(str_c("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-3_metaG_diff_abundant_diet_", p, "of", max(tmp$page),".svg"),
         width = 15, height = height, limitsize = F)
  ggsave(str_c("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-3_metaG_diff_abundant_diet_", p, "of", max(tmp$page),".png"),
         width = 15, height = height, limitsize = F)
}
```

```{r fig s3-3 full, fig.width = 15, fig.height = 40, include = F, eval = F}
# --PLOTTING ALL DIFFERENTIALLY ABUNDANT MAGs: DIET, FULL VIEW--------------
metag_daa_signif %>% 
  filter(category == "diet") %>% 
  arrange(desc(log2FoldChange)) %>% 
  mutate(label = factor(label, levels = unique(label))) %>% 
  select(category, contrast, MAG, log2FoldChange, padj, baseMean,
         label, taxonomy, phylum, lowest,
         bar_start, bar_stop, bar_label, bar_y) %>% 
  left_join(metag_vst %>% rownames_to_column("MAG") %>%
              pivot_longer(-MAG, names_to = "sample", values_to = "vst"), by = "MAG") %>% 
  left_join(sample_meta %>% filter(layer == "metaG"), by = "sample") %>% 
  
  ggplot() +
  
  # boxplots
  geom_boxplot(aes(diet, vst, fill = diet, colour = diet), outliers = F, alpha = 0.7) +
  scale_colour_manual(values = darken(annot_colours$diet, 0.2)) +
  scale_fill_manual(values = annot_colours$diet) +
  guides(fill = guide_legend(title = "diet group", order = 1, ncol = 1),
         colour = guide_legend(title = "diet group", order = 1, ncol = 1)) +
  
  # points
  new_scale_colour() +
  geom_point(aes(diet, vst, shape = type, colour = dev_stage), size = 4,
             position = position_jitterdodge(jitter.width = 0.3, dodge.width = 0.7)) +
  scale_colour_manual(values = darken(annot_colours$dev_stage, 0.2)) +
  guides(colour = guide_legend(title = "AcGGM introduction", order = 3, ncol = 1,
                             override.aes = list(shape = 15, size = 5)),
         shape = guide_none()) +
  
  # significance bars
  geom_signif(data = metag_daa_signif %>% filter(category == "diet"),
              aes(xmin = bar_start, xmax = bar_stop,
                  y_position = bar_y, annotations = bar_label),
              manual = T, colour = "grey30",
              textsize = 4.5, vjust = 1.4, size = 0.3, tip_length = 0.05) +
  
  # facets
  facet_wrap2(vars(fct_inorder(label)), ncol = 4, scales = "free",
              strip = strip_themed(background_x = elem_list_rect(fill = alpha(annot_colours$phylum[metag_daa_signif %>% filter(category == "diet") %>% arrange(desc(log2FoldChange)) %>% mutate(label = factor(label, levels = unique(label))) %>% select(label, phylum) %>% distinct() %>% pull(phylum)], 0.6)))) +
  
  # dummy points to generate facet strip colour legend
    ggnewscale::new_scale_color() +
    geom_point(aes(Inf, Inf, colour = phylum), alpha = 0, shape = 15) +
    scale_colour_manual(values = annot_colours$phylum,
                        breaks = metag_daa_signif %>% 
  filter(category == "diet") %>% distinct(phylum) %>% pull(phylum) %>% sort()) +
    guides(colour = guide_legend(title = "phylum", order = 4, nrow = 3,
                                 override.aes = list(alpha = 1, size = 6))) +
  # text labels
  labs(title = "Differentially abundant populations: diet group",
       x = element_blank(),
       y = "abundance (vst)") +
  
  # appearance
  theme(axis.title = element_text(size = 15),
        axis.text = element_text(size = 13),
        
        strip.text = element_text(size = 13),
        plot.title = element_text(hjust = 0.5, size = 17, face = "bold"),
        
        legend.position = "top",
        legend.title.position = "top",
        legend.title = element_text(size = 15, hjust = 0.5),
        legend.text = element_text(size = 14, vjust = 0.5),
        legend.spacing.x = unit(50, "pt"),
        legend.key.spacing.x = unit(15, "pt"),
        
        panel.background = element_rect(fill = "grey97"),
        plot.background = element_rect(fill = "white"),
        strip.background = element_rect(fill = "grey87"),
        panel.grid = element_blank())
```

```{r save fig s2-1 full, eval = F, include = F}
# compute height based on num. facet rows
height <- 1.8 + 2.96667 * ceiling(nrow(distinct(metag_daa_signif %>% 
                  filter(category == "diet") %>% select(label)))/facets_per_row)

# locally
ggsave("figures/supplements/S3-3_metaG_diff_abundant_diet_full.svg", width = 15, height = height, limitsize = F)
ggsave("figures/supplements/S3-3_metaG_diff_abundant_diet_full.png", width = 15, height = height, limitsize = F)

# cloud
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-3_metaG_diff_abundant_diet_full.png", width = 15, height = height, limitsize = F)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-3_metaG_diff_abundant_diet_full.svg", width = 15, height = height, limitsize = F)
```

```{r show fig s2-1, echo = F}
slickR(list.files("figures/supplements", "S3.3.*diet.*of.*.png", full.names = T),
       height = "500px") + settings(dots = T, infinite = F)
```

<br><br><br><br><font size="2">***Figure S3.3**. Differentially abundant metagenome-assembled genomes in microbiomes of animals given different diets. Significance is indicated with horizontal bars, reporting log2 fold change and false discovery rate-adjusted p-values (\* \< 0.05, \*\* \< 0.01, \*\*\* \<0.001).*</font>

------------------------------------------------------------------------

<br>

##### Development stage {.unnumbered}

```{r fig 3-4 paged, fig.width = 15, fig.height = 16.7, eval = F, results = F, fig.show = "hide"}
# --PLOTTING ALL DIFFERENTIALLY ABUNDANT MAGs: DEV STAGE, PAGED VIEW--------------
tmp <- metag_daa_signif %>% 
  filter(category == "dev_stage") %>% 
  arrange(desc(log2FoldChange)) %>% 
  mutate(label = factor(label, levels = unique(label))) %>% 
  select(category, contrast, MAG, log2FoldChange, padj, baseMean,
         label, taxonomy, phylum, lowest,
         bar_start, bar_stop, bar_label, bar_y) %>% 
  left_join(metag_vst %>% rownames_to_column("MAG") %>%
              pivot_longer(-MAG, names_to = "sample", values_to = "vst"), by = "MAG") %>% 
  
  # avoid double points if sample participates in more than one significant contrast
  group_by(MAG, sample) %>% 
  mutate(duplicate = ifelse(row_number() > 1, 0, 4)) %>% 
  ungroup() %>% 
  
  # add metadata and page numbers
  left_join(sample_meta %>% filter(layer == "metaG"), by = "sample") %>% 
  group_by(label) %>%
  mutate(num = as.integer(label)-1,
         page = ifelse(num < facets_per_row*(facetrows_per_page-1), 0,
                       floor((num-facets_per_row*(facetrows_per_page-1))/
                                    (facets_per_row*facetrows_per_page))+1),
         num = num +1,
         page = page +1) %>% 
  ungroup()

for(p in unique(tmp$page)) {
  tmp %>%
    # subset data
    filter(page == p) %>% 
    
    # plot
    ggplot() +
    
    # boxplots
    geom_boxplot(aes(dev_stage, vst, fill = dev_stage, colour = dev_stage),
                 outliers = F, alpha = 0.7) +
    
    # points
    geom_point(aes(dev_stage, vst, shape = type, colour = dev_stage, size = duplicate), 
               position = position_jitter(width = 0.3)) +
    scale_size_identity() +
    
    # colour scheme
    scale_colour_manual(values = darken(annot_colours$dev_stage, 0.2)) +
    scale_fill_manual(values = annot_colours$dev_stage) +
    guides(fill = guide_legend(title = "AcGGM introduction", order = 1, ncol = 1),
           colour = guide_legend(title = "AcGGM introduction", order = 1, ncol = 1,
                                 override.aes = list(shape = 15, size = 3)),
           shape = guide_none()) +
    
    # significance bars
    geom_signif(data = tmp %>% filter(page == p),
                aes(xmin = bar_start, xmax = bar_stop,
                    y_position = bar_y, annotations = bar_label),
                manual = T, colour = "grey30", textsize = 4.5, vjust = 1.4,
                size = 0.3, tip_length = 0.05, extend_line = -0.005) +
    
    # facets
    facet_wrap2(vars(fct_inorder(label)), ncol = 4, scales = "free",
                strip = strip_themed(background_x = elem_list_rect(fill = alpha(annot_colours$phylum[tmp %>% filter(page == p) %>% arrange(desc(log2FoldChange)) %>% mutate(label = factor(label)) %>% select(label, phylum) %>% distinct() %>% pull(phylum)], 0.6)))) +
    
    # dummy points to generate facet strip colour legend
      ggnewscale::new_scale_color() +
      geom_point(aes(Inf, Inf, colour = phylum), alpha = 0, shape = 15) +
      scale_colour_manual(values = annot_colours$phylum,
                          breaks = tmp %>% filter(page == p) %>%
                            distinct(phylum) %>% pull(phylum) %>% sort()) +
      guides(colour = guide_legend(title = "phylum", order = 4, nrow = 3,
                                   override.aes = list(alpha = 1, size = 6))) +
    # text labels
    labs(title = str_c("Differentially abundant populations: developmental stage (", p, "/", max(tmp$page), ")"),
         x = element_blank(),
         y = "abundance (vst)") +
    scale_x_discrete(labels = function(x){str_replace_all(x, "weaning*", "wng")}) +
    
    # appearance
    theme(axis.title = element_text(size = 15),
          axis.text = element_text(size = 13),
          
          strip.text = element_text(size = 13),
          plot.title = element_text(hjust = 0.5, size = 17, face = "bold"),
          
          legend.position = "top",
          legend.title.position = "top",
          legend.title = element_text(size = 15, hjust = 0.5),
          legend.text = element_text(size = 14, vjust = 0.5),
          legend.spacing.x = unit(50, "pt"),
          legend.key.spacing.x = unit(15, "pt"),
          
          panel.background = element_rect(fill = "grey97"),
          plot.background = element_rect(fill = "white"),
          strip.background = element_rect(fill = "grey87"),
          panel.grid = element_blank())
  
  # save figure
  ## compute height based on num. facet rows
  height <- 1.8 + 2.96667 * ceiling(nrow(distinct(tmp %>% filter(page == p) %>% select(label)))/facets_per_row)
  
  ## save locally
  ggsave(str_c("figures/supplements/S3-4_metaG_diff_abundant_dev_stage_", p, "of", max(tmp$page),".svg"),
         width = 15, height = height, limitsize = F)
  ggsave(str_c("figures/supplements/S3-4_metaG_diff_abundant_dev_stage_", p, "of", max(tmp$page),".png"),
         width = 15, height = height, limitsize = F)
  
  ## cloud
  ggsave(str_c("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-4_metaG_diff_abundant_dev_stage_", p, "of", max(tmp$page),".svg"),
         width = 15, height = height, limitsize = F)
  ggsave(str_c("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-4_metaG_diff_abundant_dev_stage_", p, "of", max(tmp$page),".png"),
         width = 15, height = height, limitsize = F)
}
```

```{r fig 3-4 full, fig.width = 15, fig.height = 105, include = F, eval = F}
# --PLOTTING ALL DIFFERENTIALLY ABUNDANT MAGs: DEV STAGE, FULL VIEW--------------
metag_daa_signif %>% 
  filter(category == "dev_stage") %>% 
  arrange(desc(log2FoldChange)) %>% 
  mutate(label = factor(label, levels = unique(label))) %>% 
  select(category, contrast, MAG, log2FoldChange, padj, baseMean,
         label, taxonomy, phylum, lowest,
         bar_start, bar_stop, bar_label, bar_y) %>% 
  left_join(metag_vst %>% rownames_to_column("MAG") %>%
              pivot_longer(-MAG, names_to = "sample", values_to = "vst"), by = "MAG", relationship = "many-to-many") %>% 
  # avoid double points if sample participates in more than one significant contrast
  group_by(MAG, sample) %>% 
  mutate(duplicate = ifelse(row_number() > 1, 0, 4)) %>% 
  ungroup() %>% 
  # add sample meta
  left_join(sample_meta %>% filter(layer == "metaG"), by = "sample") %>% 
  
  ggplot() +
  
  # boxplots
  geom_boxplot(aes(dev_stage, vst, fill = dev_stage, colour = dev_stage),
               outliers = F, alpha = 0.7) +
  
  # points
  geom_point(aes(dev_stage, vst, shape = type, colour = dev_stage, size = duplicate),
             position = position_jitterdodge(jitter.width = 0.3, dodge.width = 0.7)) +
  scale_size_identity()+
  
  # colour scheme
  scale_colour_manual(values = darken(annot_colours$dev_stage, 0.2)) +
  scale_fill_manual(values = annot_colours$dev_stage) +
  guides(fill = guide_legend(title = "AcGGM introduction", order = 1, nrow = 3),
         colour = guide_legend(title = "AcGGM introduction", order = 1, nrow = 3,
                               override.aes = list(shape = 15, size = 3)),
         shape = guide_none()) +
  
  # significance bars
  geom_signif(data = metag_daa_signif %>% filter(category == "dev_stage"),
              aes(xmin = bar_start, xmax = bar_stop,
                  y_position = bar_y, annotations = bar_label),
              manual = T, colour = "grey30", textsize = 4.5, vjust = 1.4,
              size = 0.3, tip_length = 0.05, extend_line = -0.005) +
  
  # facets
  facet_wrap2(vars(fct_inorder(label)), ncol = 4, scales = "free",
              strip = strip_themed(background_x = elem_list_rect(fill = alpha(annot_colours$phylum[metag_daa_signif %>% filter(category == "dev_stage") %>% arrange(desc(log2FoldChange)) %>% mutate(label = factor(label)) %>% select(label, phylum) %>% distinct() %>% pull(phylum)], 0.6)))) +
  
  # dummy points to generate facet strip colour legend
    ggnewscale::new_scale_color() +
    geom_point(aes(Inf, Inf, colour = phylum), alpha = 0, shape = 15) +
    scale_colour_manual(values = annot_colours$phylum,
                        breaks = metag_daa_signif %>% filter(category == "dev_stage") %>%
                          distinct(phylum) %>% pull(phylum) %>% sort()) +
    guides(colour = guide_legend(title = "phylum", order = 4, nrow = 3,
                                 override.aes = list(alpha = 1, size = 6))) +
  # text labels
  labs(title = "Differentially abundant populations: development stage",
       x = element_blank(),
       y = "abundance (vst)") +
  scale_x_discrete(labels = function(x){str_replace_all(x, "weaning*", "wng")}) +
  
  # appearance
  theme(axis.title = element_text(size = 15),
        axis.text = element_text(size = 13),
        
        strip.text = element_text(size = 13),
        plot.title = element_text(hjust = 0.5, size = 17, face = "bold"),
        
        legend.position = "top",
        legend.title.position = "top",
        legend.title = element_text(size = 15, hjust = 0.5),
        legend.text = element_text(size = 14, vjust = 0.5),
        legend.spacing.x = unit(50, "pt"),
        legend.key.spacing.x = unit(15, "pt"),
        
        panel.background = element_rect(fill = "grey97"),
        plot.background = element_rect(fill = "white"),
        strip.background = element_rect(fill = "grey87"),
        panel.grid = element_blank())
```

```{r save fig s3-4 full, eval = F, include = F}
# compute height based on num. facet rows
height <- 1.8 + 2.96667 * ceiling(nrow(distinct(metag_daa_signif %>% 
                  filter(category == "dev_stage") %>% select(label)))/facets_per_row)

# locally
ggsave("figures/supplements/S3-4_metaG_diff_abundant_dev_stage_full.svg", width = 15, height = height, limitsize = F)
ggsave("figures/supplements/S3-4_metaG_diff_abundant_dev_stage_full.png", width = 15, height = height, limitsize = F)

# cloud
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-4_metaG_diff_abundant_dev_stage_full.png", width = 15, height = height, limitsize = F)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-4_metaG_diff_abundant_dev_stage_full.svg", width = 15, height = height, limitsize = F)
```

```{r show fig s3-4, echo = F}
slickR(list.files("figures/supplements", "S3.4.*dev_stage.*of.*.png",
                  full.names = T), height = "500px") + settings(dots = T, infinite = F)
```

<br><br><br><br><font size="2">***Figure S3.4**. Differentially abundant metagenome-assembled genomes in microbiomes of animals introduced to acetylated galactoglucomannan fibres starting at different developmental stages. Significance is indicated with horizontal bars, reporting log2 fold change and false discovery rate-adjusted p-values (\* \< 0.05, \*\* \< 0.01, \*\*\* \<0.001).*</font>

------------------------------------------------------------------------

<br>

#### Metabolomics {.unnumbered}

```{r fig s3-5 full, fig.width = 15, fig.height = 5.76667, include = F, eval = F}
# --PLOTTING ALL DIFFERENTIALLY ABUNDANT METABOLITES: DIET AND DEVSTAGE, FULL VIEW--------------
tmp <- metab_daa_signif %>%
  filter(type == "digesta") %>% 
  filter(category != "type") %>% 
  arrange(desc(log2FoldChange)) %>% 
  mutate(label = factor(label, levels = unique(label))) %>% 
  select(category, contrast, type, id, log2FoldChange, padj,
         label, name, formula, flag,
         bar_start, bar_stop, bar_label, bar_y) %>% 
  left_join(metab_log2 %>% select(ends_with("I")) %>% rownames_to_column("id") %>%
              pivot_longer(-id, names_to = "sample", values_to = "log2"),
            by = "id", relationship = "many-to-many") %>% 
  # avoid double points if sample participates in more than one significant contrast
  group_by(id, sample) %>% 
  mutate(duplicate = ifelse(row_number() > 1, 0, 4)) %>% 
  ungroup() %>% 
  # add metadata
  left_join(sample_meta %>% select(sample, diet, dev_stage, animal), by = "sample") %>% 
  
  mutate(x_axis = ifelse(category == "diet", as.character(diet), as.character(dev_stage)),
         x_axis = factor(x_axis, levels = c("control", "AcGGM", "post-weaning", "pre-weaning"))) %>% 
  rbind(metab_daa_signif %>% 
  filter(type == "tissue", category != "type") %>% 
  arrange(desc(log2FoldChange)) %>% 
  mutate(label = factor(label, levels = unique(label))) %>% 
  select(category, contrast, type, id, log2FoldChange, padj,
         label, name, formula, flag,
         bar_start, bar_stop, bar_label, bar_y) %>% 
  left_join(metab_log2 %>% select(ends_with("K")) %>% rownames_to_column("id") %>%
              pivot_longer(-id, names_to = "sample", values_to = "log2"),
            by = "id", relationship = "many-to-many") %>% 
  # avoid double points if sample participates in more than one significant contrast
  group_by(id, sample) %>% 
  mutate(duplicate = ifelse(row_number() > 1, 0, 4)) %>% 
  ungroup() %>% 
  # add metadata
  left_join(sample_meta %>% select(sample, diet, dev_stage, animal), by = "sample") %>% 
  
  mutate(x_axis = ifelse(category == "diet", as.character(diet), as.character(dev_stage)),
         x_axis = factor(x_axis, levels = c("control", "AcGGM", "post-weaning", "pre-weaning"))))

# plot
tmp %>% 
  ggplot() +
  
  # boxplots
  geom_boxplot(aes(x_axis, log2, fill = x_axis, colour = x_axis), outliers = F, alpha = 0.7) +
  scale_colour_manual(values = darken(c(annot_colours$diet, annot_colours$dev_stage), 0.2),
                      breaks = c("control", "post-weaning", "pre-weaning", "AcGGM")) +
  scale_fill_manual(values = c(annot_colours$diet, annot_colours$dev_stage),
                    breaks = c("control", "post-weaning", "pre-weaning", "AcGGM")) +
  guides(fill = guide_legend(title = "diet group", order = 1, nrow = 3),
         colour = guide_legend(title = "diet group", order = 1, nrow = 3)) +
  
  # points
  new_scale_colour() +
  geom_point(aes(x_axis, log2, colour = x_axis, size = duplicate),
             position = position_jitter(width = 0.3)) +
  scale_size_identity() +
  scale_colour_manual(values = darken(c(annot_colours$dev_stage, annot_colours$diet), 0.2),
                      breaks = c("control", "post-weaning", "pre-weaning", "AcGGM")) +
  guides(colour = guide_legend(title = "diet group", order = 1, nrow = 1)) +
  
  # significance bars
  geom_signif(data = metab_daa_signif %>% filter(type == "digesta", category != "type"),
              aes(xmin = bar_start, xmax = bar_stop,
                  y_position = bar_y, annotations = bar_label),
              manual = T, colour = "grey30",
              textsize = 4.5, vjust = 1.4, size = 0.3, tip_length = 0.05) +
  
  # facets
  facet_nested_wrap(vars(fct_inorder(label)), scales = "free", ncol = 4,
              strip = strip_themed(background_x = elem_list_rect(fill = alpha(annot_colours$type[tmp %>% select(label, type) %>% distinct() %>% pull(type)], 0.6)))) +
  
  # dummy points to generate facet strip colour legend
    ggnewscale::new_scale_color() +
    geom_point(aes(Inf, Inf, colour = type), alpha = 0, shape = 15) +
    scale_colour_manual(values = annot_colours$type) +
    guides(colour = guide_legend(title = "sample type", order = 3, nrow = 3,
                                 override.aes = list(alpha = 1, size = 6))) +
  # text labels
  labs(title = "Differentially abundant metabolites",
       x = element_blank(),
       y = "abundance (log2)") +
  scale_x_discrete(labels = function(x){str_replace_all(x, "weaning*", "wng")}) +
  
  # appearance
  theme(axis.title = element_text(size = 15),
        axis.text = element_text(size = 13),
        
        strip.text = element_text(size = 13),
        plot.title = element_text(hjust = 0.5, size = 17, face = "bold"),
        
        legend.position = "top",
        legend.title.position = "top",
        legend.title = element_text(size = 15, hjust = 0.5),
        legend.text = element_text(size = 14, vjust = 0.5),
        legend.spacing.x = unit(50, "pt"),
        legend.key.spacing.x = unit(15, "pt"),
        
        panel.background = element_rect(fill = "grey97"),
        plot.background = element_rect(fill = "white"),
        strip.background = element_rect(fill = "grey87"),
        panel.grid = element_blank())
```

```{r save fig s3-5 full, eval = F, include = F}
# compute height based on num. facet rows
height <- 2.8 + 2.96667 * ceiling(nrow(distinct(tmp %>% 
                  select(type, label)))/facets_per_row)

# locally
ggsave("figures/supplements/S3-5_metaB_diff_abundant.svg", width = 15, height = height, limitsize = F)
ggsave("figures/supplements/S3-5_metaB_diff_abundant.png", width = 15, height = height, limitsize = F)

# cloud
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-5_metaB_diff_abundant.png", width = 15, height = height, limitsize = F)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-5_metaB_diff_abundant.svg", width = 15, height = height, limitsize = F)
```

```{r show fig s3-5, echo = F, out.width="70%"}
include_graphics(list.files("figures/supplements", "S3.5.*metaB.*png", full.names = T))
```

<font size="2">***Figure S3.5**. Differentially abundant metabolites in digesta or tissue samples of animals introduced to acetylated galactoglucomannan fibres at different developmental stages. Significance is indicated with horizontal bars, reporting log2 fold change and false discovery rate-adjusted p-values (\* \< 0.05, \*\* \< 0.01, \*\*\* \<0.001).*</font>

------------------------------------------------------------------------

<br>

#### Host transcriptomics {.tabset .unnumbered}

##### Diet group {.unnumbered}

```{r fig 3-6 paged, fig.width = 15, fig.height = 10.3, eval = F}
# --PLOTTING ALL DIFFERENTIALLY EXPRESSED HOST GENES: DIET, PAGED VIEW--------------
hostt_dea_signif %>% 
  filter(category == "diet") %>% 
  arrange(desc(log2FoldChange)) %>% 
  mutate(label = factor(label, levels = unique(label))) %>% 
  select(category, contrast, gene, log2FoldChange, padj, baseMean,
         label, annotation,
         bar_start, bar_stop, bar_label, bar_y) %>% 
  left_join(hostt_vst %>% rownames_to_column("gene") %>%
              pivot_longer(-gene, names_to = "sample", values_to = "vst"), by = "gene") %>% 
  left_join(sample_meta, by = "sample") %>% 
  
  # plot
  ggplot() +
  
  # boxplots
  geom_boxplot(aes(diet, vst, fill = diet, colour = diet), outliers = F, alpha = 0.7) +
  scale_colour_manual(values = darken(annot_colours$diet, 0.2)) +
  scale_fill_manual(values = annot_colours$diet) +
  guides(fill = guide_legend(title = "diet group", order = 1, nrow = 1),
         colour = guide_legend(title = "diet group", order = 1, nrow = 1)) +
  
  # points
  new_scale_colour() +
  geom_point(aes(diet, vst, colour = dev_stage), size = 4,
             position = position_jitterdodge(jitter.width = 0.3, dodge.width = 0.7)) +
  scale_colour_manual(values = darken(annot_colours$dev_stage, 0.2)) +
  guides(colour = guide_legend(title = "AcGGM introduction", order = 3, nrow = 1,
                             override.aes = list(shape = 15, size = 5))) +
  
  # significance bars
  geom_signif(data = hostt_dea_signif %>% filter(category == "diet"),
              aes(xmin = bar_start, xmax = bar_stop,
                  y_position = bar_y, annotations = bar_label),
              manual = T, colour = "grey30",
              textsize = 4.5, vjust = 1.4, size = 0.3, tip_length = 0.05) +
  
  # facets
  facet_wrap2(vars(fct_inorder(label)), ncol = 4, scales = "free") +
  
  # text labels
  labs(title = str_c("Differentially expressed host genes: diet group"),
       x = element_blank(),
       y = "expression level (vst)") +
  
  # appearance
  theme(axis.title = element_text(size = 15),
        axis.text = element_text(size = 13),
        
        strip.text = element_text(size = 13),
        plot.title = element_text(hjust = 0.5, size = 17, face = "bold"),
        
        legend.position = "top",
        legend.title.position = "top",
        legend.title = element_text(size = 15, hjust = 0.5),
        legend.text = element_text(size = 14, vjust = 0.5),
        legend.spacing.x = unit(50, "pt"),
        legend.key.spacing.x = unit(15, "pt"),
        
        panel.background = element_rect(fill = "grey97"),
        plot.background = element_rect(fill = "white"),
        strip.background = element_rect(fill = "grey87"),
        panel.grid = element_blank())
```

```{r save fig s3-6, eval = F, include = F}
# save figure
## compute height based on num. facet rows
height <- 1.43 + 2.96667 * ceiling(nrow(distinct(hostt_dea_signif %>% 
                           filter(category == "diet") %>% select(label)))/facets_per_row)

## locally
ggsave(str_c("figures/supplements/S3-6_hostT_diff_expressed_diet.svg"),
       width = 15, height = height, limitsize = F)
ggsave(str_c("figures/supplements/S3-6_hostT_diff_expressed_diet.png"),
       width = 15, height = height, limitsize = F)

# cloud
ggsave(str_c("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-6_hostT_diff_expressed_diet.svg"),
       width = 15, height = height, limitsize = F)
ggsave(str_c("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-6_hostT_diff_expressed_diet.png"),
       width = 15, height = height, limitsize = F)
```

```{r show fig s2-4, echo = F, out.width="70%"}
include_graphics(list.files("figures/supplements", "S3.6.*hostT.*png", full.names = T))
```

<font size="2">***Figure S3.6**. Differentially expressed genes in caecal gut wall samples of animals given different diets. Significance is indicated with horizontal bars, reporting log2 fold change and false discovery rate-adjusted p-values (\* \< 0.05, \*\* \< 0.01, \*\*\* \<0.001).*</font>

------------------------------------------------------------------------

<br>

##### Developmental stage {.unnumbered}

```{r fig 3-7, fig.width = 15, fig.height = 19.6, eval = F, results = F, fig.show = "hide"}
# --PLOTTING ALL DIFFERENTIALLY EXPRESSED HOST GENES: DEV STAGE, PAGED VIEW--------------
tmp <- hostt_dea_signif %>% 
  filter(category == "dev_stage") %>% 
  arrange(desc(log2FoldChange)) %>% 
  mutate(label = str_c(gene, ifelse(is.na(annotation), "",
                             str_c("\n", str_wrap(annotation, width = 36)))),
         label = factor(label, levels = unique(label))) %>% 
  select(category, contrast, gene, log2FoldChange, padj, baseMean,
         label, annotation,
         bar_start, bar_stop, bar_label, bar_y) %>% 
  left_join(hostt_vst %>% rownames_to_column("gene") %>%
              pivot_longer(-gene, names_to = "sample", values_to = "vst"),
            by = "gene", relationship = "many-to-many") %>% 
  # avoid double points if sample participates in more than one significant contrast
  group_by(gene, sample) %>% 
  mutate(duplicate = ifelse(row_number() > 1, 0, 4)) %>% 
  ungroup() %>% 
  # add metadata
  left_join(sample_meta, by = "sample") %>% 
  group_by(label) %>%
  mutate(num = as.integer(label)-1,
         page = ifelse(num < facets_per_row*(facetrows_per_page-1), 0,
                       floor((num-facets_per_row*(facetrows_per_page-1))/
                                    (facets_per_row*facetrows_per_page))+1),
         num = num +1,
         page = page +1) %>% 
  ungroup()

for(p in unique(tmp$page)) {
  tmp %>%
    # subset data
    filter(page == p) %>% 
    
    # plot
    ggplot() +
    
    # boxplots
    geom_boxplot(aes(dev_stage, vst, fill = dev_stage, colour = dev_stage),
                 outliers = F, alpha = 0.7) +
    
    # points
    geom_point(aes(dev_stage, vst, colour = dev_stage, size = duplicate),
               position = position_jitterdodge(jitter.width = 0.3, dodge.width = 0.7)) +
    scale_size_identity() +
    
    # colour scheme
    scale_colour_manual(values = darken(annot_colours$dev_stage, 0.2)) +
    scale_fill_manual(values = annot_colours$dev_stage) +
    guides(fill = guide_legend(title = "AcGGM introduction", order = 1, nrow = 1),
           colour = guide_legend(title = "AcGGM introduction", order = 1, nrow = 1,
                                 override.aes = list(shape = 15, size = 3))) +
    
    # significance bars
    geom_signif(data = tmp %>% filter(page == p),
                aes(xmin = bar_start, xmax = bar_stop,
                    y_position = bar_y, annotations = bar_label),
                manual = T, colour = "grey30", textsize = 4.5, vjust = 1.4,
                size = 0.3, tip_length = 0.05, extend_line = -0.005) +
    
    # facets
    facet_wrap2(vars(fct_inorder(label)), ncol = 4, scales = "free") +
    
     # text labels
    labs(title = str_c("Differentially expressed host genes: developmental stage (", p, "/", max(tmp$page), ")"),
         x = element_blank(),
         y = "expression level (vst)") +
    scale_x_discrete(labels = function(x){str_replace_all(x, "weaning*", "wng")}) +
    
    # appearance
    theme(axis.title = element_text(size = 15),
          axis.text = element_text(size = 13),
          
          strip.text = element_text(size = 13),
          plot.title = element_text(hjust = 0.5, size = 17, face = "bold"),
          
          legend.position = "top",
          legend.title.position = "top",
          legend.title = element_text(size = 15, hjust = 0.5),
          legend.text = element_text(size = 14, vjust = 0.5),
          legend.spacing.x = unit(50, "pt"),
          legend.key.spacing.x = unit(15, "pt"),
          
          panel.background = element_rect(fill = "grey97"),
          plot.background = element_rect(fill = "white"),
          strip.background = element_rect(fill = "grey87"),
          panel.grid = element_blank())
  
  # save figure
  ## compute height based on num. facet rows
  height <- 1.43 + 2.96667 * ceiling(nrow(distinct(tmp %>% filter(page == p) %>% select(label)))/facets_per_row)
  
  ## save locally
  ggsave(str_c("figures/supplements/S3-7_hostT_diff_expressed_dev_stage_", p, "of", max(tmp$page),".svg"),
         width = 15, height = height, limitsize = F)
  ggsave(str_c("figures/supplements/S3-7_hostT_diff_expressed_dev_stage_", p, "of", max(tmp$page),".png"),
         width = 15, height = height, limitsize = F)
  
  ## cloud
  ggsave(str_c("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-7_hostT_diff_expressed_dev_stage_", p, "of", max(tmp$page),".svg"),
         width = 15, height = height, limitsize = F)
  ggsave(str_c("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-7_hostT_diff_expressed_dev_stage_", p, "of", max(tmp$page),".png"),
         width = 15, height = height, limitsize = F)
}
```

```{r fig s3-7 full, fig.width = 15, fig.height = 76, include = F, eval = F}
# --PLOTTING ALL DIFFERENTIALLY ABUNDANT MAGs: DEV STAGE, FULL VIEW--------------
hostt_dea_signif %>% 
  filter(category == "dev_stage") %>% 
  arrange(desc(log2FoldChange)) %>% 
  mutate(label = str_c(gene, ifelse(is.na(annotation), "",
                             str_c("\n", str_wrap(annotation, width = 36)))),
         label = factor(label, levels = unique(label))) %>% 
  select(category, contrast, gene, log2FoldChange, padj, baseMean,
         label, annotation,
         bar_start, bar_stop, bar_label, bar_y) %>% 
  left_join(hostt_vst %>% rownames_to_column("gene") %>%
              pivot_longer(-gene, names_to = "sample", values_to = "vst"),
            by = "gene", relationship = "many-to-many") %>% 
  # avoid double points if sample participates in more than one significant contrast
  group_by(gene, sample) %>% 
  mutate(duplicate = ifelse(row_number() > 1, 0, 4)) %>% 
  ungroup() %>% 
  # add metadata
  left_join(sample_meta, by = "sample") %>% 
  
  ggplot() +
  # boxplots
  geom_boxplot(aes(dev_stage, vst, fill = dev_stage, colour = dev_stage),
               outliers = F, alpha = 0.7) +
  
  # points
  geom_point(aes(dev_stage, vst, colour = dev_stage, size = duplicate),
             position = position_jitterdodge(jitter.width = 0.3, dodge.width = 0.7)) +
  scale_size_identity() +
  
  # colour scheme
  scale_colour_manual(values = darken(annot_colours$dev_stage, 0.2)) +
  scale_fill_manual(values = annot_colours$dev_stage) +
  guides(fill = guide_legend(title = "AcGGM introduction", order = 1, nrow = 1),
         colour = guide_legend(title = "AcGGM introduction", order = 1, nrow = 1,
                               override.aes = list(shape = 15, size = 3))) +
  
  # significance bars
  geom_signif(data = hostt_dea_signif %>% filter(category == "dev_stage") %>%
                arrange(desc(log2FoldChange)) %>% 
                mutate(label = str_c(gene, ifelse(is.na(annotation), "",
                                           str_c("\n", str_wrap(annotation, width = 36)))),
                       label = factor(label, levels = unique(label))),
              aes(xmin = bar_start, xmax = bar_stop,
                  y_position = bar_y, annotations = bar_label),
              manual = T, colour = "grey30", textsize = 4.5, vjust = 1.4,
              size = 0.3, tip_length = 0.05, extend_line = -0.005) +
  
  # facets
  facet_wrap2(vars(fct_inorder(label)), ncol = 4, scales = "free") +
 
  # text labels
  labs(title = "Differentially expressed host genes: development stage",
       x = element_blank(),
       y = "expression level (vst)") +
  scale_x_discrete(labels = function(x){str_replace_all(x, "weaning*", "wng")}) +
  
  # appearance
  theme(axis.title = element_text(size = 15),
        axis.text = element_text(size = 13),
        
        strip.text = element_text(size = 13),
        plot.title = element_text(hjust = 0.5, size = 17, face = "bold"),
        
        legend.position = "top",
        legend.title.position = "top",
        legend.title = element_text(size = 15, hjust = 0.5),
        legend.text = element_text(size = 14, vjust = 0.5),
        legend.spacing.x = unit(50, "pt"),
        legend.key.spacing.x = unit(15, "pt"),
        
        panel.background = element_rect(fill = "grey97"),
        plot.background = element_rect(fill = "white"),
        strip.background = element_rect(fill = "grey87"),
        panel.grid = element_blank())
```

```{r save fig s3-7, eval = F, include = F}
# compute height based on num. facet rows
height <- 1.43 + 2.96667 * ceiling(nrow(distinct(hostt_dea_signif %>% 
                  filter(category == "dev_stage") %>% select(label)))/facets_per_row)

# locally
ggsave("figures/supplements/S3-7_hostT_diff_expressed_dev_stage_full.svg", width = 15, height = height, limitsize = F)
ggsave("figures/supplements/S3-7_hostT_diff_expressed_dev_stage_full.png", width = 15, height = height, limitsize = F)

# cloud
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-7_hostT_diff expressed_dev_stage_full.png", width = 15, height = height, limitsize = F)
ggsave("/Users/jennymerkesvik/Library/CloudStorage/OneDrive-NorwegianUniversityofLifeSciences/PhD Jenny Merkesvik/thesis/PAPER 2 - 3.2 pilot/figures/supplements/S3-7_hostT_diff_expressed_dev_stage_full.svg", width = 15, height = height, limitsize = F)
```

```{r show fig s3-7, echo = F}
slickR(list.files("figures/supplements", "S3.7.*host.*dev_stage.*of.*.png", full.names = T), height = "500px") +
  settings(dots = T, infinite = F)
```

<br><br><br><br><font size="2">***Figure S3.7**. Differentially expressed genes in caecal gut wall samples of animals introduced to acetylated galactoglucomannan fibres starting at different developmental stages. Significance is indicated with horizontal bars, reporting log2 fold change and false discovery rate-adjusted p-values (\* \< 0.05, \*\* \< 0.01, \*\*\* \<0.001).*</font>

```{r remove tmp variable, echo = F}
rm(tmp)
```

------------------------------------------------------------------------

<br>

# Session info {.unnumbered}

```{r session info, echo = F}
sessionInfo()
```
